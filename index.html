<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Dungeon - Smooth Transition Update</title>
    <style>
        :root {
            --bg-color: #2c3e50;
            --board-bg: #34495e;
            --accent: #f1c40f;
            --text: #ecf0f1;
            --armor-color: #bdc3c7;
            --modal-bg: rgba(0, 0, 0, 0.9);
            --overlay-bg: rgba(0, 0, 0, 0.85);
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px;
            user-select: none;
            font-size: 14px; 
            touch-action: manipulation;
            overflow: hidden; /* Prevent scroll during shakes */
        }
        
        /* --- ANIMATIONS & TRANSITIONS --- */
        
        /* 1. Death Animation (Spin & Shrink) */
        .dying {
            animation: deathAnim 1.5s forwards ease-in-out;
            pointer-events: none;
        }
        @keyframes deathAnim {
            0% { transform: scale(1) rotate(0deg); filter: hue-rotate(0deg); opacity: 1; }
            20% { transform: scale(1.2) rotate(-10deg); filter: hue-rotate(90deg) brightness(2); }
            40% { transform: scale(0.9) rotate(10deg); filter: hue-rotate(180deg); }
            60% { transform: scale(0.8) rotate(-5deg); opacity: 0.8; }
            100% { transform: scale(0) rotate(720deg); opacity: 0; }
        }

        /* 2. Player Death (Grayscale Fade) */
        .gray-out {
            filter: grayscale(100%) blur(2px);
            transition: filter 2s ease;
        }

        /* 3. Screen Shake */
        .shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        /* 4. Smooth Overlay Fade */
        .game-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: var(--overlay-bg);
            z-index: 50;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            backdrop-filter: blur(4px);
            
            /* Transition Logic */
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.8s ease-in-out;
        }
        
        .game-overlay.visible {
            opacity: 1;
            pointer-events: all;
        }

        /* --- STANDARD UI --- */
        .top-bar {
            width: 340px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .version { font-size: 0.8rem; color: #7f8c8d; font-family: monospace; }
        .help-btn {
            background: none; border: 1px solid #7f8c8d; color: #bdc3c7;
            padding: 4px 10px; font-size: 0.9rem; cursor: pointer; border-radius: 4px;
        }

        .turn-indicator {
            font-size: 1.2rem; font-weight: bold; padding: 5px 20px;
            border-radius: 20px; background: #222; color: #777;
            margin-bottom: 5px; transition: all 0.3s;
        }
        .turn-player { background: #2ecc71; color: #fff; box-shadow: 0 0 10px #2ecc71; }
        .turn-enemy { background: #e74c3c; color: #fff; box-shadow: 0 0 10px #e74c3c; }

        .hud {
            width: 340px; display: flex; justify-content: space-between;
            margin-bottom: 10px; background: rgba(0,0,0,0.2);
            padding: 10px; border-radius: 8px;
        }
        .stat-box { text-align: center; width: 100px; }
        .stat-box div:first-child { font-weight: bold; font-size: 0.9rem; margin-bottom: 2px; }
        
        .bar-container {
            width: 100%; height: 10px; background: #444;
            border-radius: 5px; overflow: hidden; margin-top: 3px; position: relative;
        }
        .armor-container {
            width: 100%; height: 6px; background: #333;
            border-radius: 3px; overflow: hidden; margin-top: 2px;
        }
        .bar { height: 100%; transition: width 0.3s; }
        #player-hp-bar { background-color: #2ecc71; width: 100%; }
        #enemy-hp-bar { background-color: #e74c3c; width: 100%; }
        #ult-bar { background-color: #f1c40f; width: 0%; }
        #player-armor-bar { background-color: var(--armor-color); width: 0%; }
        #enemy-armor-bar { background-color: var(--armor-color); width: 0%; }
        .hp-text { font-size: 0.8rem; display: block; margin-top: 2px; font-weight: bold; }
        .armor-text { color: var(--armor-color); font-size: 0.75rem; font-weight: bold; }

        /* Game Board */
        .grid {
            width: 320px; height: 320px; 
            display: flex; flex-wrap: wrap;
            background-color: var(--board-bg);
            border-radius: 8px; border: 4px solid #1a252f;
            overflow: hidden; position: relative;
            touch-action: none;
            transition: filter 1s ease; /* For Grayscale transition */
        }
        .grid.locked { pointer-events: none; filter: grayscale(0.5); }

        .tile {
            width: 40px; height: 40px; font-size: 24px;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; box-sizing: border-box; z-index: 1;
            transition: transform 0.2s, filter 0.2s;
        }
        .tile:hover { filter: brightness(1.2); transform: scale(1.1); z-index: 2; }
        .selected {
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid var(--accent); border-radius: 4px; transform: scale(1.1);
        }
        .falling { animation: dropIn 0.4s ease-out; }
        @keyframes dropIn {
            0% { transform: translateY(-40px); opacity: 0; }
            100% { transform: translateY(0px); opacity: 1; }
        }
        .matched {
            animation: matchPop 0.4s forwards ease-in-out; z-index: 10;
        }
        @keyframes matchPop {
            0% { transform: scale(1); filter: brightness(2) drop-shadow(0 0 5px white); background-color: rgba(255,255,255,0.4); }
            40% { transform: scale(1.3); opacity: 1; }
            100% { transform: scale(0); opacity: 0; }
        }

        /* Overlay Content */
        .overlay-title { font-size: 1.8rem; color: var(--accent); margin-bottom: 15px; text-shadow: 2px 2px 0 #000; }
        .overlay-btn {
            padding: 15px 30px; font-size: 1.1rem; background: #27ae60;
            color: white; border: 2px solid #2ecc71; border-radius: 8px;
            cursor: pointer; margin: 10px; transition: all 0.2s; font-weight: bold;
        }
        .overlay-btn:hover { background: #2ecc71; transform: scale(1.05); }
        .reward-container { 
            display: flex; 
            flex-direction: column; 
            gap: 5px; /* Reduced gap */
            width: 95%; 
            max-height: 300px; /* Limits height */
            overflow-y: auto; /* Adds scroll if needed */
        }

        /* Add this new rule below it to make buttons smaller */
        .reward-btn {
            padding: 6px 10px; /* Slimmer buttons */
            font-size: 0.85rem;
        }
        .reward-btn b { color: var(--accent); font-size: 1rem; }

        /* Enemy Cursor */
        .ai-cursor {
            position: absolute; width: 38px; height: 38px;
            border: 3px solid #e74c3c; border-radius: 50%;
            z-index: 10; transition: all 0.5s ease;
            pointer-events: none; box-shadow: 0 0 10px #e74c3c; display: none;
        }

        /* Popups */
        .pop-text {
            position: absolute; font-weight: bold; font-size: 1.4rem;
            pointer-events: none; animation: floatUp 1.5s forwards;
            text-shadow: 2px 2px 0 #000; z-index: 20; white-space: nowrap;
        }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(0.8); opacity: 0; }
            20% { transform: translateY(-10px) scale(1.2); opacity: 1; }
            80% { opacity: 1; }
            100% { transform: translateY(-60px) scale(1); opacity: 0; }
        }

        /* Monster Display */
        .enemy-display {
            font-size: 3rem; margin-bottom: 5px;
            animation: float 3s ease-in-out infinite;
            transition: transform 0.2s, filter 0.2s;
        }
        #enemy-name { font-size: 1.2rem; font-weight: bold; margin-bottom: 5px; }
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        /* Log */
        #log {
            width: 340px; height: 120px; background: rgba(0,0,0,0.4);
            margin-top: 10px; padding: 8px; font-size: 0.85rem;
            overflow-y: auto; border-radius: 6px; font-family: 'Consolas', monospace;
            display: flex; flex-direction: column-reverse; border: 1px solid #555;
        }
        .log-hit { color: #f1c40f; }
        .log-crit { color: #ff6b6b; font-weight: bold; }
        .log-heal { color: #2ecc71; }
        .log-armor { color: #bdc3c7; }
        .log-enemy { color: #e74c3c; }
        .log-match { color: #3498db; }
        .log-turn { color: #fff; font-weight: bold; text-decoration: underline; margin-top: 5px; padding-top: 5px; border-top: 1px dashed #444;}

        .action-btn {
            margin-top: 10px; padding: 12px 25px; background: var(--accent);
            border: none; cursor: pointer; font-weight: bold; border-radius: 6px;
            font-size: 1rem; color: #2c3e50; width: 340px;
        }
        .action-btn:disabled { background: #555; color: #888; cursor: not-allowed; }

        /* INFO MODAL */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--modal-bg); z-index: 100; display: none;
            justify-content: center; align-items: center;
        }
        .modal-content {
            background: #34495e; width: 90%; max-width: 400px;
            max-height: 80vh; overflow-y: auto; border-radius: 8px;
            padding: 20px; border: 2px solid #7f8c8d; position: relative;
            font-size: 0.9rem;
        }
        .close-modal {
            position: absolute; top: 10px; right: 15px; font-size: 1.5rem;
            cursor: pointer; color: #bdc3c7;
        }
        .modal-section { margin-bottom: 20px; border-bottom: 1px solid #555; padding-bottom: 15px; }
        .modal-title { color: var(--accent); margin-top: 0; font-size: 1.4rem; }
        .dual-lang { display: flex; flex-direction: column; gap: 20px; }
        h4 { margin-bottom: 5px; color: #3498db; font-size: 1.1rem; }
        ul { padding-left: 20px; margin-top: 5px; }
        li { margin-bottom: 5px; }
    </style>
</head>
<body>
    <div id="info-modal" class="modal-overlay">
        <span class="close-modal" onclick="toggleModal()">√ó</span>

        <div class="modal-section">
            <h2 class="modal-title">PIXEL DUNGEON ACADEMY</h2>
            <p>Welcome, Traveler! To survive this dungeon, you must master the grid and your hero's unique soul.</p>
        </div>

        <div class="modal-section">
            <h4>üî• THE BASICS (Nasƒ±l Oynanƒ±r?)</h4>
            <ul>
                <li><b>Match 3:</b> Drag tiles to align 3 of the same type. This performs an action and ends your turn.</li>
                <li><b>Match 4 or 5:</b> Rewards you with an <b>EXTRA TURN</b>. Skilled players hunt for these to stay in control.</li>
                <li><b>Chain Reactions:</b> If falling tiles create a match of 4 or 5, you get another turn!</li>
            </ul>
        </div>

        <div class="modal-section">
            <h4>üíé TILE TYPES (Ta≈ü √ñzellikleri)</h4>
            <ul>
                <li>‚öîÔ∏è <b>Sword:</b> Deals direct damage to the enemy's HP (or Armor).</li>
                <li>üõ°Ô∏è <b>Shield:</b> Builds your Armor bar. Armor absorbs damage before your HP drops.</li>
                <li>üíñ <b>Heart:</b> Restores your Health Points (HP).</li>
                <li>‚ö° <b>Energy:</b> Charges your <b>ULTIMATE</b> bar at the bottom.</li>
                <li>üíÄ <b>Skull:</b> Dangerous! Deals huge damage to the enemy but usually hurts you too (Recoil).</li>
            </ul>
        </div>



        <div class="modal-section">
            <h2 class="modal-title">CLASS STRATEGIES (Sƒ±nƒ±f Rehberi)</h2>
            
            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px;">
                <p><b>üõ°Ô∏è Warrior:</b> Focus on matching <b>Shields</b>. Since your Ultimate deals more damage the more Armor you have, spend the first half of the fight building a massive defense, then "Slam" them for the finish.</p>
                
                <p><b>ü™ì Berserker:</b> You are a glass cannon. Don't worry about Armor; just match <b>Swords</b>. Your goal is to kill the enemy before your low defense catches up to you.</p>
                
                <p><b>üó°Ô∏è Rogue:</b> Watch the board for <b>Matches of 4</b>. Your passive helps you get Ultimates faster. Use your Ult to finish a turn, then use the free extra turn it gives you to start a new combo.</p>
                
                <p><b>üèπ Archer:</b> Unlike other classes, you should <b>hunt for Skulls</b>. They are your strongest weapon and they won't hurt you. Keep the enemy's HP low with constant Skull pressure.</p>
                
                <p><b>üßô Mage:</b> Match <b>Energy</b> above all else. Your first few "Arcane Blasts" might feel weak, but by Level 5+, your Ultimate will become an unstoppable one-shot nuke.</p>
            </div>
        </div>

        <div class="modal-section" style="border:none;">
            <h4 style="color:#777">v0.18.0 - Hero Academy Update</h4>
            <p>TIP: Check your Combat Log (bottom) to see exactly how much damage you are dealing!</p>
        </div>
                <h4 style="color:#777">v0.18.0 - Hero Academy</h4>
                <p>Added Class Selection, Unique Ultimates, and Class Passives. Fixed death blur bug and Berserker armor scaling.</p>
            </div>
        </div>
    </div>

    <div class="top-bar">
        <div class="version">v0.18.0 Hero Academy</div> <button class="help-btn" onclick="toggleModal()">Help / Yardƒ±m</button>
        <button class="help-btn" onclick="toggleModal()">Help / Yardƒ±m</button>
    </div>
    
    <div class="enemy-display" id="enemy-sprite">üëæ</div>
    <div id="enemy-name">Slime Lvl 1</div>
    
    <div id="turn-banner" class="turn-indicator turn-player">WAITING...</div>

    <div class="hud">
        <div class="stat-box">
            <div>YOU</div>
            <div class="bar-container"><div id="player-hp-bar" class="bar"></div></div>
            <div class="armor-container"><div id="player-armor-bar" class="bar"></div></div>
            <span id="hp-text" class="hp-text">100/100</span>
        </div>
        
        <div class="stat-box" style="width: 80px;">
            <div>ULT</div>
            <div class="bar-container"><div id="ult-bar" class="bar"></div></div>
        </div>
        
        <div class="stat-box">
            <div>ENEMY</div>
            <div class="bar-container"><div id="enemy-hp-bar" class="bar"></div></div>
            <div class="armor-container"><div id="enemy-armor-bar" class="bar"></div></div>
            <span id="enemy-hp-text" class="hp-text">50/50</span>
        </div>
    </div>

    <div class="grid" id="grid">
        <div class="ai-cursor" id="ai-cursor"></div>
        <div id="game-overlay" class="game-overlay visible">
            <h1 id="overlay-title" class="overlay-title">SELECT YOUR HERO</h1>
            <div id="class-selection" class="reward-container"></div>
    
            <div id="reward-area" class="reward-container" style="display:none;"></div>
            <button id="overlay-btn" class="overlay-btn" style="display:none;" onclick="handleOverlayClick()">START BATTLE</button>
        </div>
    </div>
    
    <div id="log"></div>
    <button onclick="useUltimate()" id="ult-btn" class="action-btn" disabled>USE ULTIMATE (Requires 100%)</button>

    <script>
        const gridDisplay = document.querySelector('.grid');
        const logDisplay = document.getElementById('log');
        const turnBanner = document.getElementById('turn-banner');
        const aiCursor = document.getElementById('ai-cursor');
        const modal = document.getElementById('info-modal');
        
        const overlay = document.getElementById('game-overlay');
        const overlayTitle = document.getElementById('overlay-title');
        const overlayBtn = document.getElementById('overlay-btn');
        const rewardArea = document.getElementById('reward-area');
        const enemySprite = document.getElementById('enemy-sprite');

        const width = 8;
        const tiles = [];

        // --- STATS ---
        let TILE_STATS = {
            sword: 6, heart: 4, shield: 5, energy: 12,
            skull_dmg: 25, skull_self: 8, ult_dmg: 35
        };

        const STATE = { START: 0, PLAYING: 1, REWARD: 2, GAMEOVER: 3 };
        let currentState = STATE.START;

        // --- CLASS DEFINITIONS ---
        const CLASSES = {
            WARRIOR: {
                name: "Warrior", emoji: "üõ°Ô∏è", desc: "High Armor & Shield efficiency.",
                passive: (stats) => { stats.shield += 2; },
                ultName: "SHIELD SLAM",
                ultEffect: () => {
                    let dmg = TILE_STATS.ult_dmg + playerArmor; 
                    inflictDamage('enemy', dmg);
                    log(`ULT: Shield Slam deals ${dmg} damage!`, "log-hit");
                }
            },
            BERSERKER: {
                name: "Berserker", emoji: "ü™ì", desc: "Huge dmg. Gains 50% less Armor.",
                passive: (stats) => { 
                    stats.sword += 4; 
                    stats.shield = Math.floor(stats.shield * 0.5); // Cuts shield efficiency in half
                },
                ultName: "BLOOD LUST",
                ultEffect: () => {
                    playerHP -= 10;
                    inflictDamage('enemy', TILE_STATS.ult_dmg * 2);
                    log(`ULT: Blood Lust deals double damage!`, "log-crit");
                }
            },
            ROGUE: {
                name: "Rogue", emoji: "üó°Ô∏è", desc: "Easier extra turns & energy.",
                passive: (stats) => { stats.energy += 5; },
                ultName: "ASSASSINATE",
                ultEffect: () => {
                    inflictDamage('enemy', TILE_STATS.ult_dmg);
                    extraTurnTriggered = true;
                    log(`ULT: Assassinate! Extra Turn granted!`, "log-match");
                }
            },
            ARCHER: {
                name: "Archer", emoji: "üèπ", desc: "High Skull dmg, no self-harm.",
                passive: (stats) => { stats.skull_dmg += 10; stats.skull_self = 0; },
                ultName: "VOLLEY",
                ultEffect: () => {
                    inflictDamage('enemy', 15);
                    setTimeout(() => inflictDamage('enemy', 15), 200);
                    setTimeout(() => inflictDamage('enemy', 15), 400);
                    log(`ULT: Volley hits 3 times!`, "log-hit");
                }
            },
            MAGE: {
                name: "Mage", emoji: "üßô", desc: "Infinite Ultimate scaling.",
                passive: (stats) => { stats.energy += 10; stats.sword -= 2; },
                ultName: "ARCANE BLAST",
                ultEffect: () => {
                    inflictDamage('enemy', TILE_STATS.ult_dmg);
                    TILE_STATS.ult_dmg += 10;
                    log(`ULT: Arcane Blast! Power increased!`, "log-match");
                }
            }
        };
        let selectedClass = null; // This will hold our choice+




        let playerHP = 100, maxPlayerHP = 100, playerArmor = 0, ultCharge = 0;
        let level = 1, enemyHP = 50, maxEnemyHP = 50, enemyArmor = 0;
        let logCounter = 1;

        let isProcessing = false;
        let isPlayerTurn = true;
        let extraTurnTriggered = false;
        
        let isMouseDown = false;
        let selectedTile = null;

        const tileTypes = [
            { type: 'sword', symbol: '‚öîÔ∏è' },
            { type: 'heart', symbol: 'üíñ' },
            { type: 'shield', symbol: 'üõ°Ô∏è' },
            { type: 'energy', symbol: '‚ö°' },
            { type: 'skull', symbol: 'üíÄ' }
        ];

        // --- INPUT LISTENERS ---
        document.body.addEventListener('mouseup', () => { isMouseDown = false; });
        document.body.addEventListener('mouseleave', () => { isMouseDown = false; });
        document.body.addEventListener('touchend', () => { isMouseDown = false; });

        // --- GAME FLOW ---
        
        function renderClassButtons() {
            const container = document.getElementById('class-selection');
            container.innerHTML = '';
            container.style.display = 'flex';
            overlayBtn.style.display = 'none'; // Hide start button until class is picked

            Object.keys(CLASSES).forEach(key => {
                const c = CLASSES[key];
                const btn = document.createElement('button');
                btn.className = 'reward-btn';
                btn.innerHTML = `<span>${c.emoji} <b>${c.name}</b></span><br><small>${c.desc}</small>`;
                btn.onclick = () => {
                    selectedClass = c;
                    
                    // This updates the HUD to show your class name (e.g., üõ°Ô∏è WARRIOR)
                    const playerBox = document.querySelector('.stat-box div:first-child');
                    playerBox.style.color = 'var(--accent)';
                    playerBox.innerHTML = `${c.emoji} ${c.name.toUpperCase()}`;

                    selectedClass.passive(TILE_STATS); // Apply the unique bonus
                    
                    // Update the Ultimate button text
                    document.getElementById('ult-btn').innerText = `USE ${c.ultName} (100%)`;
                    
                    // Clean up the menu
                    container.style.display = 'none';
                    overlayTitle.innerText = `READY, ${c.name.toUpperCase()}?`;
                    overlayBtn.style.display = 'block';
                };
                container.appendChild(btn);
            });
        }

        function handleOverlayClick() {
            // Only show class selection if game hasn't started or player just died
            if (currentState === STATE.START || currentState === STATE.GAMEOVER) {
                if (!selectedClass) {
                    renderClassButtons();
                    overlayTitle.innerText = "SELECT YOUR HERO";
                    return;
                }
                resetGame();
                startLevel();
            } else if (currentState === STATE.REWARD) {
                // Keeps the same class for the next level
                startLevel();
            }
        }

        function resetGame() {
            playerHP = 100; maxPlayerHP = 100; playerArmor = 0; ultCharge = 0;
            level = 1; logCounter = 1;
            
            // Reset base stats first
            TILE_STATS = { sword: 6, heart: 4, shield: 5, energy: 12, skull_dmg: 25, skull_self: 8, ult_dmg: 35 };
            
            // Re-apply the selected class passive now that stats are fresh
            if (selectedClass) {
                selectedClass.passive(TILE_STATS);
            }
            
            isProcessing = false;
            extraTurnTriggered = false;
            gridDisplay.classList.remove('shake');
            enemySprite.classList.remove('dying');
            
            log("Game Reset.", "log-turn");
        }

        function startLevel() {
            currentState = STATE.PLAYING;
            
            // Fade out overlay
            overlay.classList.remove('visible');
            rewardArea.style.display = 'none';
            
            // Reset grid locks
            gridDisplay.classList.remove('locked');

            // Reset Enemy Visuals
            enemySprite.classList.remove('dying');
            enemySprite.classList.add('enemy-display');

            // Setup Enemy Stats
            maxEnemyHP = 50 + ((level - 1) * 20);
            enemyHP = maxEnemyHP;
            enemyArmor = 0;
            
            document.getElementById('enemy-name').innerText = `Enemy Lvl ${level}`;
            document.getElementById('enemy-sprite').innerText = ['üëæ','üëπ','üë∫','üëª','ü§ñ'][level % 5];
            
            turnBanner.innerText = "PLAYER TURN";
            turnBanner.className = "turn-indicator turn-player";
            isPlayerTurn = true;
            isProcessing = false;
            
            createBoard();
            updateUI();
            log(`LEVEL ${level} START`, "log-turn");
        }

        // --- TRANSITION SEQUENCES ---

        function checkWinCondition() {
            if (currentState !== STATE.PLAYING) return;

            if (playerHP <= 0) {
                triggerDeathSequence('player');
            }
            else if (enemyHP <= 0) {
                triggerDeathSequence('enemy');
            }
        }

        function triggerDeathSequence(who) {
            currentState = STATE.GAMEOVER; // Block input
            isProcessing = true; 

            if (who === 'enemy') {
                // Enemy dies
                enemySprite.classList.remove('enemy-display'); // Stop floating
                enemySprite.classList.add('dying'); // Start spin/shrink
                
                log("ENEMY DEFEATED!", "log-crit");
                gridDisplay.classList.add('shake'); // Shake screen
                setTimeout(() => gridDisplay.classList.remove('shake'), 500);

                // Wait for animation
                setTimeout(() => {
                    winLevel();
                }, 1500);

            } else {
                // Player dies
                gridDisplay.classList.add('shake');
                setTimeout(() => gridDisplay.classList.remove('shake'), 500);
                
                log("YOU DIED...", "log-enemy");

                setTimeout(() => {
                    gameOver();
                }, 1500);
            }
        }

        function winLevel() {
            if (currentState === STATE.REWARD) return; 
            currentState = STATE.REWARD;

            log("Level Complete! Choose a reward.", "log-hit");
            
            generateRewards();
            overlayTitle.innerText = "VICTORY!";
            overlayBtn.style.display = 'none';
            rewardArea.style.display = 'flex';
            
            // Fade In Overlay
            overlay.classList.add('visible');
        }

        function gameOver() {
            currentState = STATE.GAMEOVER;
            overlayTitle.innerText = "GAME OVER";
            overlayBtn.innerText = "TRY AGAIN";
            overlayBtn.style.display = 'block';
            rewardArea.style.display = 'none';
            overlay.classList.add('visible');
            
            selectedClass = null; // Forces a new selection on next click
        }

        function generateRewards() {
            rewardArea.innerHTML = '';
            const pool = [
                { id: 'sword', en: "Sharpen Swords (+1 Dmg)", tr: "Kƒ±lƒ±√ßlarƒ± Bile (+1 Hasar)", fn: () => TILE_STATS.sword += 1 },
                { id: 'shield', en: "Reinforce Shields (+1 Armor)", tr: "Kalkanlarƒ± G√º√ßlendir (+1 Zƒ±rh)", fn: () => TILE_STATS.shield += 1 },
                { id: 'heart', en: "Potent Potions (+1 Heal)", tr: "G√º√ßl√º ƒ∞ksirler (+1 Can)", fn: () => TILE_STATS.heart += 1 },
                { id: 'hp', en: "Vitality (+20 Max HP)", tr: "Canlƒ±lƒ±k (+20 Max Can)", fn: () => { maxPlayerHP += 20; playerHP += 20; } },
                { id: 'energy', en: "Focus (+2 Ult Charge)", tr: "Odaklanma (+2 ≈ûarj)", fn: () => TILE_STATS.energy += 2 },
                { id: 'ult', en: "Ult Power (+10 Dmg)", tr: "Ulti G√ºc√º (+10 Hasar)", fn: () => TILE_STATS.ult_dmg += 10 }
            ];
            pool.sort(() => 0.5 - Math.random());
            const choices = pool.slice(0, 3);
            choices.forEach(reward => {
                let btn = document.createElement('button');
                btn.className = 'reward-btn';
                btn.innerHTML = `<b>${reward.en}</b><br><small>${reward.tr}</small>`;
                btn.onclick = () => {
                    reward.fn();
                    log(`Upgraded: ${reward.en}`, "log-heal");
                    showReadyForNext();
                };
                rewardArea.appendChild(btn);
            });
        }

        function showReadyForNext() {
            rewardArea.style.display = 'none';
            overlayTitle.innerText = `READY FOR LEVEL ${level + 1}?`;
            overlayBtn.innerText = "START NEXT LEVEL";
            overlayBtn.style.display = 'block';
            playerHP = Math.min(playerHP + 10, maxPlayerHP);
            level++;
        }

        function toggleModal() {
            modal.style.display = (modal.style.display === 'flex') ? 'none' : 'flex';
        }

        // --- GRID LOGIC ---

        function createBoard() {
            gridDisplay.innerHTML = ''; 
            gridDisplay.appendChild(aiCursor); 
            gridDisplay.appendChild(overlay); 
            tiles.length = 0;
            for (let i = 0; i < width * width; i++) {
                const tile = document.createElement('div');
                tile.setAttribute('id', i);
                let randomType = Math.floor(Math.random() * tileTypes.length);
                tile.dataset.type = tileTypes[randomType].type;
                tile.innerHTML = tileTypes[randomType].symbol;
                tile.classList.add('tile');
                gridDisplay.appendChild(tile);
                tiles.push(tile);
                
                tile.addEventListener('mousedown', (e) => { e.preventDefault(); handleInputStart(tile); });
                tile.addEventListener('mouseenter', (e) => { e.preventDefault(); handleInputEnter(tile); });
                tile.addEventListener('touchstart', (e) => { e.preventDefault(); handleInputStart(tile); }, {passive: false});
                tile.addEventListener('touchmove', (e) => { 
                    e.preventDefault(); 
                    let touch = e.touches[0];
                    let target = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (target && target.classList.contains('tile')) handleInputEnter(target);
                }, {passive: false});
            }
            resolveMatches(true); 
            updateUI();
        }

        function handleInputStart(tile) {
            if (currentState !== STATE.PLAYING || isProcessing || !isPlayerTurn) return;
            
            isMouseDown = true;
            if (!selectedTile) {
                selectedTile = tile;
                tile.classList.add('selected');
            } else {
                if (tile !== selectedTile) checkAndSwap(selectedTile, tile);
                else {
                    selectedTile.classList.remove('selected');
                    selectedTile = null;
                }
            }
        }

        function handleInputEnter(tile) {
            if (!isMouseDown || !selectedTile || isProcessing) return;
            if (tile !== selectedTile) checkAndSwap(selectedTile, tile);
        }

        function checkAndSwap(tile1, tile2) {
            let id1 = parseInt(tile1.id), id2 = parseInt(tile2.id);
            const validMoves = [id1 - 1, id1 + 1, id1 - width, id1 + width];
            if (validMoves.includes(id2)) {
                attemptSwap(tile1, tile2);
                tile1.classList.remove('selected');
                selectedTile = null;
                isMouseDown = false; 
            } else if (!isMouseDown) { 
                tile1.classList.remove('selected');
                selectedTile = tile2;
                tile2.classList.add('selected');
            }
        }

        function attemptSwap(tile1, tile2) {
            isProcessing = true;
            let tempType = tile1.dataset.type; let tempHTML = tile1.innerHTML;
            tile1.dataset.type = tile2.dataset.type; tile1.innerHTML = tile2.innerHTML;
            tile2.dataset.type = tempType; tile2.innerHTML = tempHTML;

            // This is a manual move, we check logic
            let hasMatch = checkForMatches(false); 
            
            if (!hasMatch) {
                setTimeout(() => {
                    let tempType = tile1.dataset.type; let tempHTML = tile1.innerHTML;
                    tile1.dataset.type = tile2.dataset.type; tile1.innerHTML = tile2.innerHTML;
                    tile2.dataset.type = tempType; tile2.innerHTML = tempHTML;
                    isProcessing = false; 
                }, 200);
            }
        }

        function resolveMatches(isInitial) {
            checkForMatches(isInitial);
        }

        function checkForMatches(isInitial) {
            if (!isInitial && currentState !== STATE.PLAYING) return false;

            let matchesFound = false;
            let hRuns = [];
            let vRuns = [];

            // Horizontal
            for (let r = 0; r < width; r++) {
                let count = 1;
                for (let c = 0; c < width; c++) {
                    let i = r * width + c;
                    if (c < width-1 && tiles[i].dataset.type !== '' && tiles[i].dataset.type === tiles[i+1].dataset.type) {
                        count++;
                    } else {
                        if (count >= 3) {
                            let indices = [];
                            for(let k=0; k<count; k++) indices.push(i-k);
                            hRuns.push({indices: indices, type: tiles[i].dataset.type});
                            matchesFound = true;
                        }
                        count = 1;
                    }
                }
            }
            // Vertical
            for (let c = 0; c < width; c++) {
                let count = 1;
                for (let r = 0; r < width; r++) {
                    let i = r * width + c;
                    if (r < width-1 && tiles[i].dataset.type !== '' && tiles[i].dataset.type === tiles[i+width].dataset.type) {
                        count++;
                    } else {
                        if (count >= 3) {
                            let indices = [];
                            for(let k=0; k<count; k++) indices.push(i-(k*width));
                            vRuns.push({indices: indices, type: tiles[i].dataset.type});
                            matchesFound = true;
                        }
                        count = 1;
                    }
                }
            }

            let finalGroups = [...hRuns, ...vRuns];
            
            if (finalGroups.length > 0) {
                finalGroups.forEach(group => processMatch(group, isInitial));
                
                if (currentState === STATE.PLAYING || isInitial) {
                    setTimeout(() => fillBoard(isInitial), 400);
                }
                return true;
            } else {
                if (!isInitial) isProcessing = false;
                return false;
            }
        }

        function processMatch(group, isInitial) {
            if (currentState !== STATE.PLAYING && !isInitial) return;

            let shape = '3';
            if (group.indices.length === 4) shape = '4';
            if (group.indices.length >= 5) shape = '5';
            
            if (!isInitial && group.indices.length > 0) {
                let typeInfo = tileTypes.find(t => t.type === group.type);
                let icon = typeInfo ? typeInfo.symbol : "?";
                let user = isPlayerTurn ? "Player" : "Enemy";
                let msg = `${user} matched ${group.indices.length} ${icon}`;
                
                if (shape === '4') msg += " (2x Bonus!)";
                if (shape === '5') msg += " (3x Bonus!)";
                
                log(msg, "log-match");
            }

            let validTiles = 0;
            group.indices.forEach(index => {
                if (tiles[index].dataset.type !== '') {
                    if (!isInitial) tiles[index].classList.add('matched');
                    else tiles[index].innerHTML = ''; 
                    tiles[index].dataset.type = '';
                    validTiles++;
                }
            });

            if (validTiles > 0 && !isInitial) {
                if (shape === '4' || shape === '5') {
                    extraTurnTriggered = true;
                    let center = tiles[group.indices[1]];
                    let text = shape === '5' ? "LEGENDARY!" : "CRITICAL!";
                    let color = shape === '5' ? "#f1c40f" : "#ff6b6b";
                    showFloatingText(text, center, color);
                }
                applyRPGEffects(group.type, shape);
            }
        }

        function showFloatingText(text, tileElement, color) {
            let rect = tileElement.getBoundingClientRect();
            let pop = document.createElement('div');
            pop.classList.add('pop-text');
            pop.innerText = text;
            pop.style.color = color;
            pop.style.left = (rect.left + window.scrollX) + 'px';
            pop.style.top = (rect.top + window.scrollY) + 'px';
            document.body.appendChild(pop);
            setTimeout(() => pop.remove(), 1500);
        }

        function applyRPGEffects(type, shape) {
            if (currentState !== STATE.PLAYING) return;

            let multiplier = 1;
            if (shape === '4') multiplier = 2;
            if (shape === '5') multiplier = 3;

            let user = isPlayerTurn ? "Player" : "Enemy";
            let target = isPlayerTurn ? 'enemy' : 'player';
            
            if (type === 'sword') {
                let baseVal = TILE_STATS.sword * multiplier;
                inflictDamage(target, baseVal);
                log(`${user} attacks for ${baseVal} dmg`, isPlayerTurn ? 'log-hit' : 'log-enemy');
            
            } else if (type === 'heart') {
                let baseVal = TILE_STATS.heart * multiplier;
                if (isPlayerTurn) playerHP = Math.min(playerHP + baseVal, maxPlayerHP);
                else enemyHP = Math.min(enemyHP + baseVal, maxEnemyHP);
                log(`${user} heals +${baseVal} HP`, 'log-heal');
            
            } else if (type === 'shield') {
                let baseVal = TILE_STATS.shield * multiplier;
                if (isPlayerTurn) playerArmor += baseVal;
                else enemyArmor += baseVal;
                log(`${user} gains +${baseVal} Armor`, 'log-armor');
            
            } else if (type === 'energy') {
                let baseVal = TILE_STATS.energy * multiplier;
                if (isPlayerTurn) {
                    ultCharge = Math.min(ultCharge + baseVal, 100);
                    log(`Ult Charge: +${baseVal}%`, 'log-hit');
                } else {
                    let absorb = Math.floor(baseVal / 2);
                    enemyHP = Math.min(enemyHP + absorb, maxEnemyHP);
                    log(`Enemy absorbs ${absorb} HP`, "log-enemy");
                }
            
            } else if (type === 'skull') {
                let dmgToOpponent = TILE_STATS.skull_dmg * (shape === '3' ? 1 : 1.5);
                let recoil = TILE_STATS.skull_self * (shape === '3' ? 1 : 1.5);
                let self = isPlayerTurn ? 'player' : 'enemy';
                
                inflictDamage(target, dmgToOpponent);
                if (isPlayerTurn && selectedClass.name === "Archer") {
                    recoil = 0; 
                }

                inflictDamage(self, recoil);
                log(`SKULLS! ${user} takes ${recoil}, Target takes ${dmgToOpponent}`, 'log-crit');
            }

            if (shape === '5' && isPlayerTurn) {
                ultCharge = 100;
                log("LEGENDARY! ULT READY!", "log-hit");
            }

            checkWinCondition();
            updateUI();
        }

        function inflictDamage(targetStr, amount) {
            // Visual Shake for damage
            if (currentState === STATE.PLAYING) {
                gridDisplay.classList.remove('shake');
                void gridDisplay.offsetWidth; // trigger reflow
                gridDisplay.classList.add('shake');
            }

            if (targetStr === 'player') {
                if (playerArmor >= amount) playerArmor -= amount; 
                else {
                    let remainder = amount - playerArmor;
                    playerArmor = 0;
                    playerHP -= remainder;
                }
            } else {
                if (enemyArmor >= amount) enemyArmor -= amount;
                else {
                    let remainder = amount - enemyArmor;
                    enemyArmor = 0;
                    enemyHP -= remainder;
                }
            }
        }

        function fillBoard(isInitial) {
            if (!isInitial && currentState !== STATE.PLAYING) return;

            for (let col = 0; col < width; col++) {
                let columnTiles = [];
                for (let row = 0; row < width; row++) {
                    let index = col + (row * width);
                    if (tiles[index].dataset.type !== '') {
                        columnTiles.push({ type: tiles[index].dataset.type, html: tiles[index].innerHTML });
                    }
                }
                let missingCount = width - columnTiles.length;
                for (let i = 0; i < missingCount; i++) {
                    let randomType = Math.floor(Math.random() * tileTypes.length);
                    columnTiles.unshift({ type: tileTypes[randomType].type, html: tileTypes[randomType].symbol, isNew: true });
                }
                for (let row = 0; row < width; row++) {
                    let index = col + (row * width);
                    let tileData = columnTiles[row];
                    if (tiles[index].dataset.type !== tileData.type || tileData.isNew) {
                        tiles[index].dataset.type = tileData.type;
                        tiles[index].innerHTML = tileData.html;
                        tiles[index].classList.remove('matched');
                        if (!isInitial) {
                            tiles[index].classList.remove('falling');
                            void tiles[index].offsetWidth; 
                            tiles[index].classList.add('falling');
                        }
                    }
                }
            }
            let chainReaction = checkForMatches(isInitial);
            if (!chainReaction && !isInitial) {
                endTurnLogic();
            }
        }

        function endTurnLogic() {
            if (currentState !== STATE.PLAYING) return;
            
            if (enemyHP <= 0 || playerHP <= 0) return;

            if (extraTurnTriggered) {
                log(isPlayerTurn ? ">> EXTRA TURN!" : ">> ENEMY EXTRA TURN!", "log-turn");
                extraTurnTriggered = false;
                isProcessing = false;
                updateUI();
                if (!isPlayerTurn) setTimeout(enemyPlayTurn, 1000); 
                else gridDisplay.classList.remove('locked'); 
            } else {
                isPlayerTurn = !isPlayerTurn;
                updateTurnBanner();
                updateUI();
                
                if (!isPlayerTurn) {
                    gridDisplay.classList.add('locked'); 
                    setTimeout(enemyPlayTurn, 1500);
                } else {
                    gridDisplay.classList.remove('locked');
                    isProcessing = false;
                }
            }
        }

        function updateTurnBanner() {
            if (isPlayerTurn) {
                turnBanner.innerText = "PLAYER TURN";
                turnBanner.className = "turn-indicator turn-player";
            } else {
                turnBanner.innerText = "ENEMY TURN";
                turnBanner.className = "turn-indicator turn-enemy";
            }
        }

        function enemyPlayTurn() {
            if (currentState !== STATE.PLAYING || enemyHP <= 0) return;

            let bestMove = findBestMove();
            if (bestMove) {
                let t1 = tiles[bestMove.index];
                let t2 = tiles[bestMove.target];
                aiCursor.style.display = 'block';
                aiCursor.style.left = (t1.offsetLeft) + 'px';
                aiCursor.style.top = (t1.offsetTop) + 'px';
                setTimeout(() => {
                    aiCursor.style.left = (t2.offsetLeft) + 'px';
                    aiCursor.style.top = (t2.offsetTop) + 'px';
                }, 500);
                setTimeout(() => {
                    aiCursor.style.display = 'none';
                    attemptSwap(t1, t2);
                }, 1000);
            } else {
                log("Enemy found no moves. Passing...", "log-enemy");
                isPlayerTurn = true;
                updateTurnBanner();
                updateUI();
                gridDisplay.classList.remove('locked');
                isProcessing = false;
            }
        }

        function findBestMove() {
            let possibleMoves = [];
            for (let i = 0; i < 64; i++) {
                let r = Math.floor(i / width);
                let c = i % width;
                if (c < width - 1) {
                    let score = simulateSwap(i, i + 1);
                    if (score > 0) possibleMoves.push({index: i, target: i + 1, score: score});
                }
                if (r < width - 1) {
                    let score = simulateSwap(i, i + width);
                    if (score > 0) possibleMoves.push({index: i, target: i + width, score: score});
                }
            }
            possibleMoves.sort((a, b) => b.score - a.score);
            return possibleMoves.length > 0 ? possibleMoves[0] : null;
        }

        function simulateSwap(i1, i2) {
            let tempTypes = tiles.map(t => t.dataset.type);
            let h = tempTypes[i1]; tempTypes[i1] = tempTypes[i2]; tempTypes[i2] = h;
            let score = 0;
             for (let r = 0; r < width; r++) {
                for (let c = 0; c < width - 2; c++) {
                    let idx = r * width + c;
                    let t = tempTypes[idx];
                    if (!t) continue;
                    if (tempTypes[idx+1] == t && tempTypes[idx+2] == t) score += calculateScore(t, 3);
                }
            }
            for (let c = 0; c < width; c++) {
                for (let r = 0; r < width - 2; r++) {
                    let idx = r * width + c;
                    let t = tempTypes[idx];
                    if (!t) continue;
                    if (tempTypes[idx+width] == t && tempTypes[idx+width*2] == t) score += calculateScore(t, 3);
                }
            }
            return score;
        }

        function calculateScore(type, length) {
            let base = 10;
            if (type === 'skull') base += 25; 
            if (type === 'shield' && enemyArmor < 10) base += 20; 
            if (type === 'sword') base += 5;
            return base;
        }

        function useUltimate() {
            if (ultCharge >= 100 && isPlayerTurn && currentState === STATE.PLAYING) {
                selectedClass.ultEffect();
                ultCharge = 0;
                log(`ULTIMATE! ${TILE_STATS.ult_dmg} Damage!`, "log-hit");
                checkWinCondition();
                updateUI();
            }
        }

        function updateUI() {
            const pPct = Math.max(0, (playerHP / maxPlayerHP) * 100);
            const ePct = Math.max(0, (enemyHP / maxEnemyHP) * 100);
            const pArmPct = Math.min(100, (playerArmor / maxPlayerHP) * 100);
            const eArmPct = Math.min(100, (enemyArmor / maxEnemyHP) * 100);

            document.getElementById('player-hp-bar').style.width = `${pPct}%`;
            document.getElementById('enemy-hp-bar').style.width = `${ePct}%`;
            document.getElementById('ult-bar').style.width = `${ultCharge}%`;
            
            document.getElementById('player-armor-bar').style.width = `${pArmPct}%`;
            document.getElementById('enemy-armor-bar').style.width = `${eArmPct}%`;
            
            let pArmorText = playerArmor > 0 ? ` <span class="armor-text">[+${playerArmor}]</span>` : "";
            let eArmorText = enemyArmor > 0 ? ` <span class="armor-text">[+${enemyArmor}]</span>` : "";

            document.getElementById('hp-text').innerHTML = `${Math.floor(Math.max(0,playerHP))}/${maxPlayerHP}${pArmorText}`;
            document.getElementById('enemy-hp-text').innerHTML = `${Math.floor(Math.max(0,enemyHP))}/${maxEnemyHP}${eArmorText}`;

            document.getElementById('ult-btn').disabled = ultCharge < 100 || !isPlayerTurn;
        }

        function log(msg, cls) {
            let div = document.createElement('div');
            div.innerText = `#${logCounter++} > ${msg}`;
            if(cls) div.classList.add(cls);
            logDisplay.prepend(div);
        }

        createBoard();
        renderClassButtons();
    </script>
</body>
</html>