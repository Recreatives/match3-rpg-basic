<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Dungeon - Scrollable & Grid Stats</title>
    <style>
        :root {
            --bg-color: #2c3e50;
            --board-bg: #34495e;
            --accent: #f1c40f;
            --text: #ecf0f1;
            --armor-color: #bdc3c7;
            --modal-bg: rgba(0, 0, 0, 0.95);
            --overlay-bg: rgba(0, 0, 0, 0.9);
            
            /* Rarity Colors */
            --common: #95a5a6;    /* Grey */
            --uncommon: #2ecc71;  /* Green */
            --rare: #3498db;      /* Blue */
            --epic: #9b59b6;      /* Purple */
            --legendary: #e67e22; /* Orange */
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px 5px 30px 5px; /* Added bottom padding for scroll space */
            user-select: none;
            font-size: 14px; 
            touch-action: manipulation;
            /* CHANGED: Allowed scrolling */
            overflow-y: auto; 
            min-height: 100vh;
        }
        
        /* --- ANIMATIONS & TRANSITIONS --- */
        .dying {
            animation: deathAnim 1.5s forwards ease-in-out;
            pointer-events: none;
        }
        @keyframes deathAnim {
            0% { transform: scale(1) rotate(0deg); filter: hue-rotate(0deg); opacity: 1; }
            20% { transform: scale(1.2) rotate(-10deg); filter: hue-rotate(90deg) brightness(2); }
            40% { transform: scale(0.9) rotate(10deg); filter: hue-rotate(180deg); }
            60% { transform: scale(0.8) rotate(-5deg); opacity: 0.8; }
            100% { transform: scale(0) rotate(720deg); opacity: 0; }
        }

        .shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        .game-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: var(--overlay-bg);
            z-index: 50;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            backdrop-filter: blur(4px);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.8s ease-in-out;
        }
        
        .game-overlay.visible {
            opacity: 1;
            pointer-events: all;
        }

        /* --- STANDARD UI --- */
        .top-bar {
            width: 340px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        .version { font-size: 0.8rem; color: #7f8c8d; font-family: monospace; }
        .help-btn {
            background: none; border: 1px solid #7f8c8d; color: #bdc3c7;
            padding: 4px 10px; font-size: 0.9rem; cursor: pointer; border-radius: 4px;
        }

        .turn-indicator {
            font-size: 1.2rem; font-weight: bold; padding: 5px 20px;
            border-radius: 20px; background: #222; color: #777;
            margin-bottom: 5px; transition: all 0.3s;
        }
        .turn-player { background: #2ecc71; color: #fff; box-shadow: 0 0 10px #2ecc71; }
        .turn-enemy { background: #e74c3c; color: #fff; box-shadow: 0 0 10px #e74c3c; }

        .hud {
            width: 340px; display: flex; justify-content: space-between;
            margin-bottom: 5px; background: rgba(0,0,0,0.2);
            padding: 10px; border-radius: 8px;
            box-sizing: border-box;
        }
        .stat-box { text-align: center; width: 100px; }
        .stat-box div:first-child { font-weight: bold; font-size: 0.9rem; margin-bottom: 2px; }
        
        .bar-container {
            width: 100%; height: 10px; background: #444;
            border-radius: 5px; overflow: hidden; margin-top: 3px; position: relative;
        }
        .armor-container {
            width: 100%; height: 6px; background: #333;
            border-radius: 3px; overflow: hidden; margin-top: 2px;
        }
        .bar { height: 100%; transition: width 0.3s; }
        #player-hp-bar { background-color: #2ecc71; width: 100%; }
        #enemy-hp-bar { background-color: #e74c3c; width: 100%; }
        #ult-bar { background-color: #f1c40f; width: 0%; }
        #player-armor-bar { background-color: var(--armor-color); width: 0%; }
        #enemy-armor-bar { background-color: var(--armor-color); width: 0%; }
        .hp-text { font-size: 0.8rem; display: block; margin-top: 2px; font-weight: bold; }
        .armor-text { color: var(--armor-color); font-size: 0.75rem; font-weight: bold; }

        /* --- STATS BAR (UPDATED TO GRID) --- */
        .stats-bar {
            width: 340px;
            display: grid; /* Changed to Grid */
            grid-template-columns: repeat(4, 1fr); /* Exactly 4 columns */
            gap: 8px; /* Gap between items */
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
            border: 1px solid #555;
            box-sizing: border-box;
        }
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            color: #bdc3c7;
        }
        .stat-item span:first-child {
            font-size: 1.2rem; /* Slightly larger icons */
            margin-bottom: 2px;
        }
        .stat-val {
            font-weight: bold;
            color: #fff;
            font-family: monospace;
            font-size: 0.9rem;
        }

        /* Game Board */
        .grid {
            width: 320px; height: 320px; 
            display: flex; flex-wrap: wrap;
            background-color: var(--board-bg);
            border-radius: 8px; border: 4px solid #1a252f;
            overflow: hidden; position: relative;
            touch-action: none;
            transition: filter 1s ease;
            flex-shrink: 0; /* Prevent grid squishing */
        }
        .grid.locked { pointer-events: none; filter: grayscale(0.5); }

        .tile {
            width: 40px; height: 40px; font-size: 24px;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; box-sizing: border-box; z-index: 1;
            transition: transform 0.2s, filter 0.2s;
        }
        .tile:hover { filter: brightness(1.2); transform: scale(1.1); z-index: 2; }
        .selected {
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid var(--accent); border-radius: 4px; transform: scale(1.1);
        }
        .falling { animation: dropIn 0.4s ease-out; }
        @keyframes dropIn {
            0% { transform: translateY(-40px); opacity: 0; }
            100% { transform: translateY(0px); opacity: 1; }
        }
        .matched {
            animation: matchPop 0.4s forwards ease-in-out; z-index: 10;
        }
        @keyframes matchPop {
            0% { transform: scale(1); filter: brightness(2) drop-shadow(0 0 5px white); background-color: rgba(255,255,255,0.4); }
            40% { transform: scale(1.3); opacity: 1; }
            100% { transform: scale(0); opacity: 0; }
        }

        /* Overlay Content */
        .overlay-title { font-size: 1.8rem; color: var(--accent); margin-bottom: 15px; text-shadow: 2px 2px 0 #000; }
        .overlay-btn {
            padding: 15px 30px; font-size: 1.1rem; background: #27ae60;
            color: white; border: 2px solid #2ecc71; border-radius: 8px;
            cursor: pointer; margin: 10px; transition: all 0.2s; font-weight: bold;
        }
        .overlay-btn:hover { background: #2ecc71; transform: scale(1.05); }
        .reward-container { 
            display: flex; 
            flex-direction: column; 
            gap: 8px; 
            width: 95%; 
            max-height: 400px; 
            overflow-y: auto; 
            padding-bottom: 20px;
        }

        .reward-btn {
            padding: 12px 15px;
            font-size: 0.95rem;
            background: rgba(30, 30, 30, 0.9);
            border-style: solid;
            border-width: 2px;
            color: white;
            cursor: pointer;
            text-align: left;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .reward-btn:hover { transform: translateX(5px); filter: brightness(1.2); }
        .reward-btn b { font-size: 1.1rem; display: block; margin-bottom: 3px; }
        .reward-btn small { color: #ecf0f1; display: block; line-height: 1.3; opacity: 0.9; }
        
        .rarity-common { border-color: var(--common); color: #fff; }
        .rarity-uncommon { border-color: var(--uncommon); background: rgba(46, 204, 113, 0.15); }
        .rarity-rare { border-color: var(--rare); background: rgba(52, 152, 219, 0.15); }
        .rarity-epic { border-color: var(--epic); background: rgba(155, 89, 182, 0.15); }
        .rarity-legendary { border-color: var(--legendary); background: rgba(230, 126, 34, 0.25); box-shadow: 0 0 15px rgba(230, 126, 34, 0.3); }

        /* Enemy Cursor */
        .ai-cursor {
            position: absolute; width: 38px; height: 38px;
            border: 3px solid #e74c3c; border-radius: 50%;
            z-index: 10; transition: all 0.5s ease;
            pointer-events: none; box-shadow: 0 0 10px #e74c3c; display: none;
        }

        /* Popups */
        .pop-text {
            position: absolute; font-weight: bold; font-size: 1.4rem;
            pointer-events: none; animation: floatUp 1.5s forwards;
            text-shadow: 2px 2px 0 #000; z-index: 20; white-space: nowrap;
        }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(0.8); opacity: 0; }
            20% { transform: translateY(-10px) scale(1.2); opacity: 1; }
            80% { opacity: 1; }
            100% { transform: translateY(-60px) scale(1); opacity: 0; }
        }

        /* Monster Display */
        .enemy-display {
            font-size: 3rem; margin-bottom: 5px;
            animation: float 3s ease-in-out infinite;
            transition: transform 0.2s, filter 0.2s;
        }
        #enemy-name { font-size: 1.2rem; font-weight: bold; margin-bottom: 5px; }
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        /* Log */
        #log {
            width: 340px; height: 100px; 
            background: rgba(0,0,0,0.4);
            margin-top: 10px; padding: 8px; font-size: 0.85rem;
            overflow-y: auto; border-radius: 6px; font-family: 'Consolas', monospace;
            display: flex; flex-direction: column-reverse; border: 1px solid #555;
            flex-shrink: 0;
        }
        .log-hit { color: #f1c40f; }
        .log-crit { color: #ff6b6b; font-weight: bold; }
        .log-heal { color: #2ecc71; }
        .log-armor { color: #bdc3c7; }
        .log-enemy { color: #e74c3c; }
        .log-match { color: #3498db; }
        .log-turn { color: #fff; font-weight: bold; text-decoration: underline; margin-top: 5px; padding-top: 5px; border-top: 1px dashed #444;}

        .action-btn {
            margin-top: 10px; padding: 12px 25px; background: var(--accent);
            border: none; cursor: pointer; font-weight: bold; border-radius: 6px;
            font-size: 1rem; color: #2c3e50; width: 340px;
            flex-shrink: 0;
            margin-bottom: 20px;
        }
        .action-btn:disabled { background: #555; color: #888; cursor: not-allowed; }

        /* INFO MODAL */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--modal-bg); z-index: 100; display: none;
            justify-content: center; align-items: center;
        }
        .modal-content {
            background: #34495e; width: 90%; max-width: 400px;
            max-height: 80vh; overflow-y: auto; border-radius: 8px;
            padding: 20px; border: 2px solid #7f8c8d; position: relative;
            font-size: 0.9rem;
        }
        .close-modal {
            position: absolute; top: 10px; right: 15px; font-size: 1.5rem;
            cursor: pointer; color: #bdc3c7;
        }
        .modal-section { margin-bottom: 20px; border-bottom: 1px solid #555; padding-bottom: 15px; }
        .modal-title { color: var(--accent); margin-top: 0; font-size: 1.4rem; }
        h4 { margin-bottom: 5px; color: #3498db; font-size: 1.1rem; }
        ul { padding-left: 20px; margin-top: 5px; }
        li { margin-bottom: 5px; }
    </style>
</head>
<body>
    <div id="info-modal" class="modal-overlay">
        <div class="modal-content">
            <span class="close-modal" onclick="toggleModal()">√ó</span>

            <div class="modal-section">
                <h2 class="modal-title">PIXEL DUNGEON MANUAL</h2>
                <p>Welcome, Traveler! Master the grid and use your class abilities to survive.</p>
            </div>

            <div class="modal-section">
                <h4>üß† ENEMY AI</h4>
                <ul>
                    <li><b>Minions (Normal Levels):</b> Clumsy. 30% chance to make mistakes.</li>
                    <li><b>Bosses (Every 5th Level):</b> Masterminds. They plan ahead and use 4-match combos.</li>
                </ul>
            </div>

            <div class="modal-section">
                <h2 class="modal-title">CLASS GUIDE</h2>
                
                <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px;">
                    <p><b>üõ°Ô∏è Warrior (Tank)</b><br>
                    Strategy: Build Armor with Shields, then use Ult to deal damage equal to your Armor.</p>
                    
                    <p><b>ü™ì Berserker (DPS)</b><br>
                    Strategy: High Sword & Skull damage, but takes 35% extra damage. Kill fast.</p>
                    
                    <p><b>üèπ Archer (Evasion)</b><br>
                    Strategy: 30% Dodge chance. Ult hits 3 times for consistent damage.</p>
                    
                    <p><b>üó°Ô∏è Rogue (Combo)</b><br>
                    Strategy: High Energy gain. Ult grants an Extra Turn.</p>
                    
                    <p><b>üßô Mage (Scaler)</b><br>
                    Strategy: Weak start. Ult gets +10 damage permanently every use.</p>
                </div>
            </div>
        </div>
    </div>

    <div class="top-bar">
        <div class="version">v0.24 Grid Stats & Scroll</div> 
        <button class="help-btn" onclick="toggleModal()">Help / Manual</button>
    </div>
    
    <div class="enemy-display" id="enemy-sprite">üëæ</div>
    <div id="enemy-name">Slime Lvl 1</div>
    
    <div id="turn-banner" class="turn-indicator turn-player">WAITING...</div>

    <div class="hud">
        <div class="stat-box">
            <div>YOU</div>
            <div class="bar-container"><div id="player-hp-bar" class="bar"></div></div>
            <div class="armor-container"><div id="player-armor-bar" class="bar"></div></div>
            <span id="hp-text" class="hp-text">100/100</span>
        </div>
        
        <div class="stat-box" style="width: 80px;">
            <div>ULT</div>
            <div class="bar-container"><div id="ult-bar" class="bar"></div></div>
        </div>
        
        <div class="stat-box">
            <div>ENEMY</div>
            <div class="bar-container"><div id="enemy-hp-bar" class="bar"></div></div>
            <div class="armor-container"><div id="enemy-armor-bar" class="bar"></div></div>
            <span id="enemy-hp-text" class="hp-text">50/50</span>
        </div>
    </div>

    <div class="stats-bar">
        <div class="stat-item" title="Sword Damage"><span>‚öîÔ∏è</span><span id="stat-sword" class="stat-val">6</span></div>
        <div class="stat-item" title="Shield Gain"><span>üõ°Ô∏è</span><span id="stat-shield" class="stat-val">5</span></div>
        <div class="stat-item" title="Heal Amount"><span>üíñ</span><span id="stat-heart" class="stat-val">4</span></div>
        <div class="stat-item" title="Energy Gain"><span>‚ö°</span><span id="stat-energy" class="stat-val">12</span></div>
        
        <div class="stat-item" title="Skull Damage"><span>üíÄ</span><span id="stat-skull" class="stat-val">25</span></div>
        <div class="stat-item" title="Self Damage"><span>‚ò†Ô∏è</span><span id="stat-self" class="stat-val">12</span></div>
        <div class="stat-item" title="Ultimate Power"><span>üí•</span><span id="stat-ult" class="stat-val">35</span></div>
        <div class="stat-item" title="Life Steal %"><span>üßõ</span><span id="stat-lifesteal" class="stat-val">0%</span></div>
    </div>

    <div class="grid" id="grid">
        <div class="ai-cursor" id="ai-cursor"></div>
        <div id="game-overlay" class="game-overlay visible">
            <h1 id="overlay-title" class="overlay-title">SELECT YOUR HERO</h1>
            <div id="class-selection" class="reward-container"></div>
    
            <div id="reward-area" class="reward-container" style="display:none;"></div>
            <button id="overlay-btn" class="overlay-btn" style="display:none;" onclick="handleOverlayClick()">START BATTLE</button>
        </div>
    </div>
    
    <div id="log"></div>
    <button onclick="useUltimate()" id="ult-btn" class="action-btn" disabled>USE ULTIMATE (Requires 100%)</button>

    <script>
        const gridDisplay = document.querySelector('.grid');
        const logDisplay = document.getElementById('log');
        const turnBanner = document.getElementById('turn-banner');
        const aiCursor = document.getElementById('ai-cursor');
        const modal = document.getElementById('info-modal');
        
        const overlay = document.getElementById('game-overlay');
        const overlayTitle = document.getElementById('overlay-title');
        const overlayBtn = document.getElementById('overlay-btn');
        const rewardArea = document.getElementById('reward-area');
        const enemySprite = document.getElementById('enemy-sprite');

        const width = 8;
        const tiles = [];

        // --- STATS ---
        let TILE_STATS = {
            sword: 6, heart: 4, shield: 5, energy: 12,
            skull_dmg: 25, skull_self: 12, ult_dmg: 35, lifeSteal: 0
        };

        const STATE = { START: 0, PLAYING: 1, REWARD: 2, GAMEOVER: 3 };
        let currentState = STATE.START;
        let rewardPicksLeft = 1;

        // --- CLASS DEFINITIONS ---
        const CLASSES = {
            WARRIOR: {
                name: "Warrior", emoji: "üõ°Ô∏è", 
                desc: "<b>Tank:</b> Gains +2 Bonus Shield. Ult deals damage based on Armor.",
                passive: (stats) => { stats.shield += 2; },
                dodgeChance: 0, incomingDmgMult: 1.0,
                ultName: "SHIELD SLAM",
                ultEffect: () => {
                    let dmg = TILE_STATS.ult_dmg + playerArmor; 
                    inflictDamage('enemy', dmg);
                    log(`ULT: Shield Slam deals ${dmg} damage!`, "log-hit");
                }
            },
            BERSERKER: {
                name: "Berserker", emoji: "ü™ì", 
                desc: "<b>DPS:</b> +5 Sword/ +15 Skull Dmg, but takes <b>35% MORE DAMAGE</b>.",
                passive: (stats) => { stats.sword += 5; stats.skull_dmg += 15; },
                dodgeChance: 0, incomingDmgMult: 1.35,
                ultName: "BLOOD LUST",
                ultEffect: () => {
                    playerHP -= 10;
                    inflictDamage('enemy', TILE_STATS.ult_dmg * 2);
                    log(`ULT: Blood Lust deals double damage!`, "log-crit");
                }
            },
            ROGUE: {
                name: "Rogue", emoji: "üó°Ô∏è", 
                desc: "<b>Combo:</b> Gains Energy fast. Ult grants an <b>EXTRA TURN</b>.",
                passive: (stats) => { stats.energy += 5; },
                dodgeChance: 0.1, incomingDmgMult: 1.0,
                ultName: "ASSASSINATE",
                ultEffect: () => {
                    inflictDamage('enemy', TILE_STATS.ult_dmg);
                    extraTurnTriggered = true;
                    log(`ULT: Assassinate! Extra Turn!`, "log-match");
                }
            },
            ARCHER: {
                name: "Archer", emoji: "üèπ", 
                desc: "<b>Evasion:</b> <b>30% Dodge Chance</b>. Best survivor.",
                passive: (stats) => {},
                dodgeChance: 0.3, incomingDmgMult: 1.0,
                ultName: "VOLLEY",
                ultEffect: () => {
                    inflictDamage('enemy', 15);
                    setTimeout(() => inflictDamage('enemy', 15), 200);
                    setTimeout(() => inflictDamage('enemy', 15), 400);
                    log(`ULT: Volley hits 3 times!`, "log-hit");
                }
            },
            MAGE: {
                name: "Mage", emoji: "üßô", 
                desc: "<b>Scaling:</b> Ult gains <b>+10 Power</b> every use.",
                passive: (stats) => { stats.energy += 10; stats.sword -= 2; },
                dodgeChance: 0, incomingDmgMult: 1.0,
                ultName: "ARCANE BLAST",
                ultEffect: () => {
                    inflictDamage('enemy', TILE_STATS.ult_dmg);
                    TILE_STATS.ult_dmg += 10;
                    log(`ULT: Power increased to ${TILE_STATS.ult_dmg}!`, "log-match");
                }
            }
        };
        let selectedClass = null; 

        let playerHP = 100, maxPlayerHP = 100, playerArmor = 0, ultCharge = 0;
        let level = 1, enemyHP = 50, maxEnemyHP = 50, enemyArmor = 0;
        let logCounter = 1;

        let isProcessing = false;
        let isPlayerTurn = true;
        let extraTurnTriggered = false;
        let isMouseDown = false;
        let selectedTile = null;

        const tileTypes = [
            { type: 'sword', symbol: '‚öîÔ∏è' },
            { type: 'heart', symbol: 'üíñ' },
            { type: 'shield', symbol: 'üõ°Ô∏è' },
            { type: 'energy', symbol: '‚ö°' },
            { type: 'skull', symbol: 'üíÄ' }
        ];

        // --- GAME FLOW ---
        
        function renderClassButtons() {
            const container = document.getElementById('class-selection');
            container.innerHTML = '';
            container.style.display = 'flex';
            overlayBtn.style.display = 'none';

            Object.keys(CLASSES).forEach(key => {
                const c = CLASSES[key];
                const btn = document.createElement('button');
                btn.className = 'reward-btn rarity-rare';
                btn.innerHTML = `<b>${c.emoji} ${c.name}</b><small>${c.desc}</small>`;
                btn.onclick = () => {
                    selectedClass = c;
                    const playerBox = document.querySelector('.stat-box div:first-child');
                    playerBox.style.color = 'var(--accent)';
                    playerBox.innerHTML = `${c.emoji} ${c.name.toUpperCase()}`;
                    selectedClass.passive(TILE_STATS); 
                    document.getElementById('ult-btn').innerText = `USE ${c.ultName} (100%)`;
                    updateUI();
                    container.style.display = 'none';
                    overlayTitle.innerText = `READY, ${c.name.toUpperCase()}?`;
                    overlayBtn.style.display = 'block';
                };
                container.appendChild(btn);
            });
        }

        function handleOverlayClick() {
            if (currentState === STATE.START || currentState === STATE.GAMEOVER) {
                if (!selectedClass) {
                    renderClassButtons();
                    overlayTitle.innerText = "SELECT YOUR HERO";
                    return;
                }
                resetGame();
                startLevel();
            }
        }

        function resetGame() {
            playerHP = 100; maxPlayerHP = 100; playerArmor = 0; ultCharge = 0;
            level = 1; logCounter = 1;
            TILE_STATS = { sword: 6, heart: 4, shield: 5, energy: 12, skull_dmg: 25, skull_self: 12, ult_dmg: 35, lifeSteal: 0 };
            if (selectedClass) selectedClass.passive(TILE_STATS);
            isProcessing = false;
            extraTurnTriggered = false;
            gridDisplay.classList.remove('shake');
            enemySprite.classList.remove('dying');
            log("Game Reset.", "log-turn");
        }

        function startLevel() {
            currentState = STATE.PLAYING;
            overlay.classList.remove('visible');
            rewardArea.style.display = 'none';
            gridDisplay.classList.remove('locked');

            enemySprite.classList.remove('dying');
            enemySprite.classList.add('enemy-display');

            maxEnemyHP = 50 + ((level - 1) * 20);
            enemyHP = maxEnemyHP;
            enemyArmor = 0;
            
            let isBoss = (level % 5 === 0);
            let name = isBoss ? `BOSS Lvl ${level}` : `Minion Lvl ${level}`;
            document.getElementById('enemy-name').innerText = name;
            document.getElementById('enemy-sprite').innerText = isBoss ? 'üëπ' : ['üëæ','üë∫','üëª','ü§ñ'][level % 4];
            
            if(isBoss) log("WARNING: BOSS BATTLE!", "log-crit");

            turnBanner.innerText = "PLAYER TURN";
            turnBanner.className = "turn-indicator turn-player";
            isPlayerTurn = true;
            isProcessing = false;
            
            createBoard();
            updateUI();
            log(`LEVEL ${level} START`, "log-turn");
        }

        function checkWinCondition() {
            if (currentState !== STATE.PLAYING) return;
            if (playerHP <= 0) triggerDeathSequence('player');
            else if (enemyHP <= 0) triggerDeathSequence('enemy');
        }

        function triggerDeathSequence(who) {
            currentState = STATE.GAMEOVER;
            isProcessing = true; 
            if (who === 'enemy') {
                enemySprite.classList.remove('enemy-display'); 
                enemySprite.classList.add('dying'); 
                log("ENEMY DEFEATED!", "log-crit");
                gridDisplay.classList.add('shake'); 
                setTimeout(() => { gridDisplay.classList.remove('shake'); winLevel(); }, 1500);
            } else {
                gridDisplay.classList.add('shake');
                setTimeout(() => { gridDisplay.classList.remove('shake'); gameOver(); }, 1500);
            }
        }

        function winLevel() {
            if (currentState === STATE.REWARD) return; 
            currentState = STATE.REWARD;

            // Calculate Reward Picks
            let hpPercent = (playerHP / maxPlayerHP);
            if (hpPercent >= 1.0) { rewardPicksLeft = 2; log("FLAWLESS! Pick 2 Rewards!", "log-hit"); }
            else if (hpPercent < 0.10) { rewardPicksLeft = 3; log("DESPERATE WIN! Pick 3 Rewards!", "log-match"); }
            else if (hpPercent < 0.01) { rewardPicksLeft = 5; log("MIRACLE! Pick 5 Rewards!", "log-crit"); }
            else { rewardPicksLeft = 1; log("Level Complete! Pick 1 Reward.", "log-hit"); }
            
            generateRewards();
            updateRewardTitle();
            overlayBtn.style.display = 'none';
            rewardArea.style.display = 'flex';
            overlay.classList.add('visible');
        }

        function updateRewardTitle() {
            if (rewardPicksLeft > 0) {
                overlayTitle.innerText = `VICTORY! PICK ${rewardPicksLeft}`;
            } else {
                overlayTitle.innerText = `READY FOR LEVEL ${level + 1}?`;
                rewardArea.style.display = 'none';
                overlayBtn.innerText = "START NEXT LEVEL";
                overlayBtn.style.display = 'block';
                overlayBtn.onclick = () => {
                    playerHP = Math.min(playerHP + 10, maxPlayerHP);
                    level++;
                    startLevel();
                };
            }
        }

        function generateRewards() {
            rewardArea.innerHTML = '';
            
            const REWARDS = [
                // === COMMON (40%) - 1 Stat ===
                { tier: 'common', name: 'Whetstone', desc: 'Sword +1', fn: () => TILE_STATS.sword += 1 },
                { tier: 'common', name: 'Leather Patch', desc: 'Shield +1', fn: () => TILE_STATS.shield += 1 },
                { tier: 'common', name: 'Herb Mix', desc: 'Heal +1', fn: () => TILE_STATS.heart += 1 },
                { tier: 'common', name: 'Meditation', desc: 'Energy +1', fn: () => TILE_STATS.energy += 1 },
                { tier: 'common', name: 'Bone Shard', desc: 'Skull +6/ Self +3', fn: () => { TILE_STATS.skull_dmg += 6; TILE_STATS.skull_self += 3; } },
                { tier: 'common', name: 'Minor Charge', desc: 'Ult Dmg +10', fn: () => TILE_STATS.ult_dmg += 10 },
                { tier: 'common', name: 'Leech Seed', desc: 'Life Steal +1%', fn: () => TILE_STATS.lifeSteal += 1 },
                
                // === UNCOMMON (30%) - 1 Stat (Stronger) ===
                { tier: 'uncommon', name: 'Steel Sword', desc: 'Sword +2', fn: () => TILE_STATS.sword += 2 },
                { tier: 'uncommon', name: 'Iron Plate', desc: 'Shield +2', fn: () => TILE_STATS.shield += 2 },
                { tier: 'uncommon', name: 'Potion', desc: 'Heal +2', fn: () => TILE_STATS.heart += 2 },
                { tier: 'uncommon', name: 'Focus', desc: 'Energy +2', fn: () => TILE_STATS.energy += 2 },
                { tier: 'uncommon', name: 'Skull Idol', desc: 'Skull +10/ Self +5', fn: () => { TILE_STATS.skull_dmg += 10; TILE_STATS.skull_self += 5; } },
                { tier: 'uncommon', name: 'Mana Crystal', desc: 'Ult Dmg +20', fn: () => TILE_STATS.ult_dmg += 20 },
                { tier: 'uncommon', name: 'Bat Wing', desc: 'Life Steal +2%', fn: () => TILE_STATS.lifeSteal += 2 },

                // === RARE (15%) - 1 Stat (Big) ===
                { tier: 'rare', name: 'Diamond Blade', desc: 'Sword +3', fn: () => TILE_STATS.sword += 3 },
                { tier: 'rare', name: 'Tower Shield', desc: 'Shield +3', fn: () => TILE_STATS.shield += 3 },
                { tier: 'rare', name: 'Elixir', desc: 'Heal +3', fn: () => TILE_STATS.heart += 3 },
                { tier: 'rare', name: 'Deep Focus', desc: 'Energy +3', fn: () => TILE_STATS.energy += 3 },
                { tier: 'rare', name: 'Cursed Skull', desc: 'Skull +14/ Self +7', fn: () => { TILE_STATS.skull_dmg += 14; TILE_STATS.skull_self += 7; } },
                { tier: 'rare', name: 'Spell Book', desc: 'Ult Dmg +35', fn: () => TILE_STATS.ult_dmg += 35 },
                { tier: 'rare', name: 'Vampire Tooth', desc: 'Life Steal +3%', fn: () => TILE_STATS.lifeSteal += 3 },

                // === EPIC (10%) - 2 Stats (Enriched Pool) ===
                { tier: 'epic', name: 'Paladin Set', desc: 'Sword +3 & Shield +3', fn: () => { TILE_STATS.sword += 3; TILE_STATS.shield += 3; } },
                { tier: 'epic', name: 'Blood Mage', desc: 'Ult +30 & Steal +3%', fn: () => { TILE_STATS.ult_dmg += 30; TILE_STATS.lifeSteal += 3; } },
                { tier: 'epic', name: 'Berserker Soul', desc: 'Skull +20(Self+10) & Sword +4', fn: () => { TILE_STATS.skull_dmg += 20; TILE_STATS.skull_self += 10; TILE_STATS.sword += 4; } },
                { tier: 'epic', name: 'Monk Vow', desc: 'Heal +4 & Energy +4', fn: () => { TILE_STATS.heart += 4; TILE_STATS.energy += 4; } },
                { tier: 'epic', name: 'Stone Skin', desc: 'Shield +4 & HP +30', fn: () => { TILE_STATS.shield += 4; maxPlayerHP += 30; playerHP += 30; } },
                { tier: 'epic', name: 'Crimson Edge', desc: 'Sword +4 & Steal +3%', fn: () => { TILE_STATS.sword += 4; TILE_STATS.lifeSteal += 3; } },
                { tier: 'epic', name: 'Storm Caller', desc: 'Energy +4 & Ult +25', fn: () => { TILE_STATS.energy += 4; TILE_STATS.ult_dmg += 25; } },
                { tier: 'epic', name: 'Iron Heart', desc: 'Shield +4 & Heal +4', fn: () => { TILE_STATS.shield += 4; TILE_STATS.heart += 4; } },
                { tier: 'epic', name: 'Necromancer', desc: 'Skull +24(Self+12) & Steal +3%', fn: () => { TILE_STATS.skull_dmg += 24; TILE_STATS.skull_self += 12; TILE_STATS.lifeSteal += 3; } },
                { tier: 'epic', name: 'Gladiator', desc: 'Sword +4 & Energy +3', fn: () => { TILE_STATS.sword += 4; TILE_STATS.energy += 3; } },
                { tier: 'epic', name: 'Giant Strength', desc: 'Max HP +40 & Sword +3', fn: () => { maxPlayerHP += 40; playerHP += 40; TILE_STATS.sword += 3; } },

                // === LEGENDARY (5%) - 3 Stats ===
                { tier: 'legendary', name: 'God Slayer', desc: 'Sword +5, Ult +40, Energy +3', fn: () => { TILE_STATS.sword += 5; TILE_STATS.ult_dmg += 40; TILE_STATS.energy += 3; } },
                { tier: 'legendary', name: 'Immortality', desc: 'Shield +5, Heal +5, Max HP +50', fn: () => { TILE_STATS.shield += 5; TILE_STATS.heart += 5; maxPlayerHP+=50; playerHP+=50; } },
                { tier: 'legendary', name: 'Demon Lord', desc: 'Skull +30(Self+15), Steal +5%, Sword +4', fn: () => { TILE_STATS.skull_dmg += 30; TILE_STATS.skull_self += 15; TILE_STATS.lifeSteal += 5; TILE_STATS.sword += 4; } },
                { tier: 'legendary', name: 'Archmage', desc: 'Energy +5, Ult +30, Shield +4', fn: () => { TILE_STATS.energy += 5; TILE_STATS.ult_dmg += 30; TILE_STATS.shield += 4; } },
                { tier: 'legendary', name: 'Trinity', desc: 'Sword +3, Shield +3, Heal +3', fn: () => { TILE_STATS.sword += 3; TILE_STATS.shield += 3; TILE_STATS.heart += 3; } },
                { tier: 'legendary', name: 'Titan Blood', desc: 'Max HP +40, Heal +4, Sword +3', fn: () => { maxPlayerHP += 40; playerHP += 40; TILE_STATS.heart += 4; TILE_STATS.sword += 3; } },
                { tier: 'legendary', name: 'Vampire King', desc: 'Life Steal +4%, Skull +20(Self+10), Energy +3', fn: () => { TILE_STATS.lifeSteal += 4; TILE_STATS.skull_dmg += 20; TILE_STATS.skull_self += 10; TILE_STATS.energy += 3; } },
                { tier: 'legendary', name: 'Juggernaut', desc: 'Max HP +60, Shield +4, Sword +2', fn: () => { maxPlayerHP += 60; playerHP += 60; TILE_STATS.shield += 4; TILE_STATS.sword += 2; } }
            ];

            for (let i = 0; i < 3; i++) {
                let rand = Math.random();
                let chosenTier = 'common';
                
                if (rand < 0.05) chosenTier = 'legendary';
                else if (rand < 0.15) chosenTier = 'epic';
                else if (rand < 0.30) chosenTier = 'rare';
                else if (rand < 0.60) chosenTier = 'uncommon';

                let pool = REWARDS.filter(r => r.tier === chosenTier);
                // Fallback if pool is empty (shouldn't happen)
                if(pool.length === 0) pool = REWARDS.filter(r => r.tier === 'common');
                
                let reward = pool[Math.floor(Math.random() * pool.length)];

                let btn = document.createElement('button');
                btn.className = `reward-btn rarity-${reward.tier}`;
                // Rarity name in parenthesis for clarity
                btn.innerHTML = `<b>${reward.name} <span style="font-size:0.7em; text-transform:uppercase; opacity:0.8;">(${reward.tier})</span></b><small>${reward.desc}</small>`;
                btn.onclick = () => {
                    reward.fn();
                    log(`Picked: ${reward.name}`, "log-heal");
                    rewardPicksLeft--;
                    
                    updateUI();
                    
                    if (rewardPicksLeft > 0) {
                        generateRewards(); 
                        updateRewardTitle();
                    } else {
                        btn.style.display = 'none'; 
                        updateRewardTitle();
                    }
                };
                rewardArea.appendChild(btn);
            }
        }

        function gameOver() {
            currentState = STATE.GAMEOVER;
            overlayTitle.innerText = "GAME OVER";
            overlayBtn.innerText = "TRY AGAIN";
            overlayBtn.style.display = 'block';
            overlayBtn.onclick = handleOverlayClick;
            rewardArea.style.display = 'none';
            overlay.classList.add('visible');
            selectedClass = null; 
        }

        // --- GAME LOGIC ---
        function createBoard() {
            gridDisplay.innerHTML = ''; 
            gridDisplay.appendChild(aiCursor); 
            gridDisplay.appendChild(overlay); 
            tiles.length = 0;
            for (let i = 0; i < width * width; i++) {
                const tile = document.createElement('div');
                tile.setAttribute('id', i);
                let randomType = Math.floor(Math.random() * tileTypes.length);
                tile.dataset.type = tileTypes[randomType].type;
                tile.innerHTML = tileTypes[randomType].symbol;
                tile.classList.add('tile');
                gridDisplay.appendChild(tile);
                tiles.push(tile);
                
                tile.addEventListener('mousedown', (e) => { e.preventDefault(); handleInputStart(tile); });
                tile.addEventListener('touchstart', (e) => { e.preventDefault(); handleInputStart(tile); }, {passive: false});
                tile.addEventListener('mouseenter', (e) => { e.preventDefault(); handleInputEnter(tile); });
                tile.addEventListener('touchmove', (e) => { 
                    e.preventDefault(); 
                    let t = e.touches[0];
                    let target = document.elementFromPoint(t.clientX, t.clientY);
                    if (target && target.classList.contains('tile')) handleInputEnter(target);
                }, {passive: false});
            }
            resolveMatches(true); 
            updateUI();
        }

        function handleInputStart(tile) {
            if (currentState !== STATE.PLAYING || isProcessing || !isPlayerTurn) return;
            isMouseDown = true;
            if (!selectedTile) {
                selectedTile = tile;
                tile.classList.add('selected');
            } else {
                if (tile !== selectedTile) checkAndSwap(selectedTile, tile);
                else {
                    selectedTile.classList.remove('selected');
                    selectedTile = null;
                }
            }
        }

        function handleInputEnter(tile) {
            if (!isMouseDown || !selectedTile || isProcessing) return;
            if (tile !== selectedTile) checkAndSwap(selectedTile, tile);
        }

        function checkAndSwap(tile1, tile2) {
            let id1 = parseInt(tile1.id), id2 = parseInt(tile2.id);
            const validMoves = [id1 - 1, id1 + 1, id1 - width, id1 + width];
            if (validMoves.includes(id2)) {
                attemptSwap(tile1, tile2);
                tile1.classList.remove('selected');
                selectedTile = null;
                isMouseDown = false; 
            } else if (!isMouseDown) { 
                tile1.classList.remove('selected');
                selectedTile = tile2;
                tile2.classList.add('selected');
            }
        }

        function attemptSwap(tile1, tile2) {
            isProcessing = true;
            let tempType = tile1.dataset.type; let tempHTML = tile1.innerHTML;
            tile1.dataset.type = tile2.dataset.type; tile1.innerHTML = tile2.innerHTML;
            tile2.dataset.type = tempType; tile2.innerHTML = tempHTML;

            let hasMatch = checkForMatches(false); 
            if (!hasMatch) {
                setTimeout(() => {
                    let tempType = tile1.dataset.type; let tempHTML = tile1.innerHTML;
                    tile1.dataset.type = tile2.dataset.type; tile1.innerHTML = tile2.innerHTML;
                    tile2.dataset.type = tempType; tile2.innerHTML = tempHTML;
                    isProcessing = false; 
                }, 200);
            }
        }

        function resolveMatches(isInitial) {
            checkForMatches(isInitial);
        }

        function checkForMatches(isInitial) {
            if (!isInitial && currentState !== STATE.PLAYING) return false;
            let matchesFound = false;
            let hRuns = [], vRuns = [];

            // Horizontal
            for (let r = 0; r < width; r++) {
                let count = 1;
                for (let c = 0; c < width; c++) {
                    let i = r * width + c;
                    if (c < width-1 && tiles[i].dataset.type !== '' && tiles[i].dataset.type === tiles[i+1].dataset.type) {
                        count++;
                    } else {
                        if (count >= 3) {
                            let indices = [];
                            for(let k=0; k<count; k++) indices.push(i-k);
                            hRuns.push({indices: indices, type: tiles[i].dataset.type});
                            matchesFound = true;
                        }
                        count = 1;
                    }
                }
            }
            // Vertical
            for (let c = 0; c < width; c++) {
                let count = 1;
                for (let r = 0; r < width; r++) {
                    let i = r * width + c;
                    if (r < width-1 && tiles[i].dataset.type !== '' && tiles[i].dataset.type === tiles[i+width].dataset.type) {
                        count++;
                    } else {
                        if (count >= 3) {
                            let indices = [];
                            for(let k=0; k<count; k++) indices.push(i-(k*width));
                            vRuns.push({indices: indices, type: tiles[i].dataset.type});
                            matchesFound = true;
                        }
                        count = 1;
                    }
                }
            }

            let finalGroups = [...hRuns, ...vRuns];
            if (finalGroups.length > 0) {
                finalGroups.forEach(group => processMatch(group, isInitial));
                if (currentState === STATE.PLAYING || isInitial) {
                    setTimeout(() => fillBoard(isInitial), 400);
                }
                return true;
            } else {
                if (!isInitial) isProcessing = false;
                return false;
            }
        }

        function processMatch(group, isInitial) {
            if (currentState !== STATE.PLAYING && !isInitial) return;
            let shape = '3';
            if (group.indices.length === 4) shape = '4';
            if (group.indices.length >= 5) shape = '5';
            
            if (!isInitial && group.indices.length > 0) {
                let typeInfo = tileTypes.find(t => t.type === group.type);
                let icon = typeInfo ? typeInfo.symbol : "?";
                let user = isPlayerTurn ? "Player" : "Enemy";
                let msg = `${user} matched ${group.indices.length} ${icon}`;
                if (shape === '4') msg += " (2x!)";
                if (shape === '5') msg += " (3x!)";
                log(msg, "log-match");
            }

            let validTiles = 0;
            group.indices.forEach(index => {
                if (tiles[index].dataset.type !== '') {
                    if (!isInitial) tiles[index].classList.add('matched');
                    else tiles[index].innerHTML = ''; 
                    tiles[index].dataset.type = '';
                    validTiles++;
                }
            });

            if (validTiles > 0 && !isInitial) {
                if (shape === '4' || shape === '5') {
                    extraTurnTriggered = true;
                    let center = tiles[group.indices[1]];
                    let text = shape === '5' ? "LEGENDARY!" : "CRITICAL!";
                    let color = shape === '5' ? "#f1c40f" : "#ff6b6b";
                    showFloatingText(text, center, color);
                }
                applyRPGEffects(group.type, shape);
            }
        }

        function showFloatingText(text, tileElement, color) {
            let rect = tileElement.getBoundingClientRect();
            let pop = document.createElement('div');
            pop.classList.add('pop-text');
            pop.innerText = text;
            pop.style.color = color;
            pop.style.left = (rect.left + window.scrollX) + 'px';
            pop.style.top = (rect.top + window.scrollY) + 'px';
            document.body.appendChild(pop);
            setTimeout(() => pop.remove(), 1500);
        }

        function applyRPGEffects(type, shape) {
            if (currentState !== STATE.PLAYING) return;
            let multiplier = 1;
            if (shape === '4') multiplier = 2;
            if (shape === '5') multiplier = 3;

            let user = isPlayerTurn ? "Player" : "Enemy";
            let target = isPlayerTurn ? 'enemy' : 'player';
            
            if (type === 'sword') {
                let baseVal = TILE_STATS.sword * multiplier;
                inflictDamage(target, baseVal);
                log(`${user} Atk ${baseVal}`, isPlayerTurn ? 'log-hit' : 'log-enemy');
            } else if (type === 'heart') {
                let baseVal = TILE_STATS.heart * multiplier;
                if (isPlayerTurn) playerHP = Math.min(playerHP + baseVal, maxPlayerHP);
                else enemyHP = Math.min(enemyHP + baseVal, maxEnemyHP);
                log(`${user} Heal +${baseVal}`, 'log-heal');
            } else if (type === 'shield') {
                let baseVal = TILE_STATS.shield * multiplier;
                if (isPlayerTurn) playerArmor += baseVal;
                else enemyArmor += baseVal;
                log(`${user} Armor +${baseVal}`, 'log-armor');
            } else if (type === 'energy') {
                let baseVal = TILE_STATS.energy * multiplier;
                if (isPlayerTurn) {
                    ultCharge = Math.min(ultCharge + baseVal, 100);
                    log(`Ult +${baseVal}%`, 'log-hit');
                } else {
                    let absorb = Math.floor(baseVal / 2);
                    enemyHP = Math.min(enemyHP + absorb, maxEnemyHP);
                    log(`Enemy Absorbs ${absorb}`, "log-enemy");
                }
            } else if (type === 'skull') {
                let dmgToOpponent = TILE_STATS.skull_dmg * (shape === '3' ? 1 : 1.5);
                let recoil = TILE_STATS.skull_self * (shape === '3' ? 1 : 1.5);
                let self = isPlayerTurn ? 'player' : 'enemy';
                inflictDamage(target, dmgToOpponent);
                inflictDamage(self, recoil);
                log(`Skull Dmg: ${dmgToOpponent} / Recoil: ${recoil}`, 'log-crit');
            }

            if (shape === '5' && isPlayerTurn) {
                ultCharge = 100;
                log("LEGENDARY! ULT READY!", "log-hit");
            }
            checkWinCondition();
            updateUI();
        }

        function inflictDamage(targetStr, amount) {
            // Dodge
            if (targetStr === 'player' && selectedClass && selectedClass.dodgeChance > 0) {
                if (Math.random() < selectedClass.dodgeChance) {
                    showFloatingText("DODGE!", document.getElementById('player-hp-bar'), "#2ecc71");
                    log("DODGED!", "log-heal");
                    return; 
                }
            }
            // Vulnerability
            if (targetStr === 'player' && selectedClass && selectedClass.incomingDmgMult) {
                amount = Math.floor(amount * selectedClass.incomingDmgMult);
            }

            // Life Steal
            if (targetStr === 'enemy' && isPlayerTurn && TILE_STATS.lifeSteal > 0) {
                let heal = Math.floor(amount * (TILE_STATS.lifeSteal / 100));
                if (heal > 0) {
                    playerHP = Math.min(playerHP + heal, maxPlayerHP);
                    log(`Life Steal +${heal}`, 'log-heal');
                }
            }

            // Visual Shake
            if (currentState === STATE.PLAYING) {
                gridDisplay.classList.remove('shake');
                void gridDisplay.offsetWidth; 
                gridDisplay.classList.add('shake');
            }

            if (targetStr === 'player') {
                if (playerArmor >= amount) playerArmor -= amount; 
                else {
                    let remainder = amount - playerArmor;
                    playerArmor = 0;
                    playerHP -= remainder;
                }
            } else {
                if (enemyArmor >= amount) enemyArmor -= amount;
                else {
                    let remainder = amount - enemyArmor;
                    enemyArmor = 0;
                    enemyHP -= remainder;
                }
            }
        }

        function fillBoard(isInitial) {
            if (!isInitial && currentState !== STATE.PLAYING) return;
            for (let col = 0; col < width; col++) {
                let columnTiles = [];
                for (let row = 0; row < width; row++) {
                    let index = col + (row * width);
                    if (tiles[index].dataset.type !== '') {
                        columnTiles.push({ type: tiles[index].dataset.type, html: tiles[index].innerHTML });
                    }
                }
                let missingCount = width - columnTiles.length;
                for (let i = 0; i < missingCount; i++) {
                    let randomType = Math.floor(Math.random() * tileTypes.length);
                    columnTiles.unshift({ type: tileTypes[randomType].type, html: tileTypes[randomType].symbol, isNew: true });
                }
                for (let row = 0; row < width; row++) {
                    let index = col + (row * width);
                    let tileData = columnTiles[row];
                    if (tiles[index].dataset.type !== tileData.type || tileData.isNew) {
                        tiles[index].dataset.type = tileData.type;
                        tiles[index].innerHTML = tileData.html;
                        tiles[index].classList.remove('matched');
                        if (!isInitial) {
                            tiles[index].classList.remove('falling');
                            void tiles[index].offsetWidth; 
                            tiles[index].classList.add('falling');
                        }
                    }
                }
            }
            let chainReaction = checkForMatches(isInitial);
            if (!chainReaction && !isInitial) endTurnLogic();
        }

        function endTurnLogic() {
            if (currentState !== STATE.PLAYING) return;
            if (enemyHP <= 0 || playerHP <= 0) return;

            if (extraTurnTriggered) {
                log(isPlayerTurn ? ">> EXTRA TURN!" : ">> ENEMY EXTRA TURN!", "log-turn");
                extraTurnTriggered = false;
                isProcessing = false;
                updateUI();
                if (!isPlayerTurn) setTimeout(enemyPlayTurn, 1000); 
                else gridDisplay.classList.remove('locked'); 
            } else {
                isPlayerTurn = !isPlayerTurn;
                updateTurnBanner();
                updateUI();
                if (!isPlayerTurn) {
                    gridDisplay.classList.add('locked'); 
                    setTimeout(enemyPlayTurn, 1500);
                } else {
                    gridDisplay.classList.remove('locked');
                    isProcessing = false;
                }
            }
        }

        function updateTurnBanner() {
            if (isPlayerTurn) {
                turnBanner.innerText = "PLAYER TURN";
                turnBanner.className = "turn-indicator turn-player";
            } else {
                turnBanner.innerText = "ENEMY TURN";
                turnBanner.className = "turn-indicator turn-enemy";
            }
        }

        function enemyPlayTurn() {
            if (currentState !== STATE.PLAYING || enemyHP <= 0) return;
            let isBoss = (level % 5 === 0);
            let move = isBoss ? findBestMove() : findMinionMove();

            if (move) {
                let t1 = tiles[move.index];
                let t2 = tiles[move.target];
                aiCursor.style.display = 'block';
                aiCursor.style.left = (t1.offsetLeft) + 'px';
                aiCursor.style.top = (t1.offsetTop) + 'px';
                setTimeout(() => {
                    aiCursor.style.left = (t2.offsetLeft) + 'px';
                    aiCursor.style.top = (t2.offsetTop) + 'px';
                }, 500);
                setTimeout(() => {
                    aiCursor.style.display = 'none';
                    attemptSwap(t1, t2);
                }, 1000);
            } else {
                log("Enemy found no moves. Passing...", "log-enemy");
                isPlayerTurn = true;
                updateTurnBanner();
                updateUI();
                gridDisplay.classList.remove('locked');
                isProcessing = false;
            }
        }

        function findBestMove() {
            let possibleMoves = [];
            for (let i = 0; i < 64; i++) {
                let r = Math.floor(i / width);
                let c = i % width;
                if (c < width - 1) {
                    let score = simulateSwap(i, i + 1);
                    if (score > 0) possibleMoves.push({index: i, target: i + 1, score: score});
                }
                if (r < width - 1) {
                    let score = simulateSwap(i, i + width);
                    if (score > 0) possibleMoves.push({index: i, target: i + width, score: score});
                }
            }
            possibleMoves.sort((a, b) => b.score - a.score);
            return possibleMoves.length > 0 ? possibleMoves[0] : null;
        }

        function findMinionMove() {
            let makeMistake = Math.random() < 0.30;
            let legalMoves = [];
            for (let i = 0; i < 64; i++) {
                let r = Math.floor(i / width);
                let c = i % width;
                if (c < width - 1) {
                    if (simulateSwap(i, i+1) > 0) {
                        if (!makeMistake) return {index: i, target: i+1}; 
                        legalMoves.push({index: i, target: i+1});
                    }
                }
                if (r < width - 1) {
                    if (simulateSwap(i, i+width) > 0) {
                        if (!makeMistake) return {index: i, target: i+width}; 
                        legalMoves.push({index: i, target: i+width});
                    }
                }
            }
            if (legalMoves.length > 0) return legalMoves[Math.floor(Math.random() * legalMoves.length)];
            return null;
        }

        function simulateSwap(i1, i2) {
            let tempTypes = tiles.map(t => t.dataset.type);
            let h = tempTypes[i1]; tempTypes[i1] = tempTypes[i2]; tempTypes[i2] = h;
            let score = 0;
            function getMatchLength(types, idx, step) {
                let type = types[idx]; if (!type) return 0;
                let count = 1; let curr = idx + step;
                while(curr >= 0 && curr < 64 && types[curr] === type) {
                    if (step === 1 && Math.floor(curr/width) !== Math.floor(idx/width)) break;
                    count++; curr += step;
                }
                return count;
            }
            let checkIndices = [i1, i2];
            for (let idx of checkIndices) {
                let r = Math.floor(idx / width), c = idx % width;
                let startC = c; while(startC > 0 && tempTypes[r*width + (startC-1)] === tempTypes[idx]) startC--;
                let hLen = getMatchLength(tempTypes, r*width + startC, 1);
                let startR = r; while(startR > 0 && tempTypes[(startR-1)*width + c] === tempTypes[idx]) startR--;
                let vLen = getMatchLength(tempTypes, startR*width + c, width);
                [hLen, vLen].forEach(len => {
                    if (len >= 5) score += 1000;
                    else if (len === 4) score += 500;
                    else if (len === 3) score += calculateScore(tempTypes[idx]);
                });
            }
            return score;
        }

        function calculateScore(type) {
            let base = 10;
            if (type === 'skull') base += 25; 
            if (type === 'shield' && enemyArmor < 10) base += 20; 
            if (type === 'sword') base += 5;
            return base;
        }

        function useUltimate() {
            if (ultCharge >= 100 && isPlayerTurn && currentState === STATE.PLAYING) {
                selectedClass.ultEffect();
                ultCharge = 0;
                log(`ULTIMATE! ${TILE_STATS.ult_dmg} Damage!`, "log-hit");
                checkWinCondition();
                updateUI();
            }
        }

        function updateUI() {
            const pPct = Math.max(0, (playerHP / maxPlayerHP) * 100);
            const ePct = Math.max(0, (enemyHP / maxEnemyHP) * 100);
            const pArmPct = Math.min(100, (playerArmor / maxPlayerHP) * 100);
            const eArmPct = Math.min(100, (enemyArmor / maxEnemyHP) * 100);

            document.getElementById('player-hp-bar').style.width = `${pPct}%`;
            document.getElementById('enemy-hp-bar').style.width = `${ePct}%`;
            document.getElementById('ult-bar').style.width = `${ultCharge}%`;
            document.getElementById('player-armor-bar').style.width = `${pArmPct}%`;
            document.getElementById('enemy-armor-bar').style.width = `${eArmPct}%`;
            
            let pArmorText = playerArmor > 0 ? ` <span class="armor-text">[+${playerArmor}]</span>` : "";
            let eArmorText = enemyArmor > 0 ? ` <span class="armor-text">[+${enemyArmor}]</span>` : "";

            document.getElementById('hp-text').innerHTML = `${Math.floor(Math.max(0,playerHP))}/${maxPlayerHP}${pArmorText}`;
            document.getElementById('enemy-hp-text').innerHTML = `${Math.floor(Math.max(0,enemyHP))}/${maxEnemyHP}${eArmorText}`;
            document.getElementById('ult-btn').disabled = ultCharge < 100 || !isPlayerTurn;

            // Updated Stats Display
            document.getElementById('stat-sword').innerText = TILE_STATS.sword;
            document.getElementById('stat-shield').innerText = TILE_STATS.shield;
            document.getElementById('stat-heart').innerText = TILE_STATS.heart;
            document.getElementById('stat-energy').innerText = TILE_STATS.energy;
            document.getElementById('stat-skull').innerText = TILE_STATS.skull_dmg;
            document.getElementById('stat-self').innerText = TILE_STATS.skull_self;
            document.getElementById('stat-ult').innerText = TILE_STATS.ult_dmg;
            document.getElementById('stat-lifesteal').innerText = TILE_STATS.lifeSteal + "%";
        }

        function toggleModal() {
            modal.style.display = (modal.style.display === 'flex') ? 'none' : 'flex';
        }

        function log(msg, cls) {
            let div = document.createElement('div');
            div.innerText = `#${logCounter++} > ${msg}`;
            if(cls) div.classList.add(cls);
            logDisplay.prepend(div);
        }

        createBoard();
        renderClassButtons();
    </script>
</body>
</html>