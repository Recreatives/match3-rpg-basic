<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Dungeon Match PvE - Drag Controls</title>
    <style>
        :root {
            --bg-color: #2c3e50;
            --board-bg: #34495e;
            --accent: #f1c40f;
            --text: #ecf0f1;
            --armor-color: #bdc3c7;
            --modal-bg: rgba(0, 0, 0, 0.85);
            --overlay-bg: rgba(0, 0, 0, 0.7);
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            user-select: none;
            font-size: 16px; 
        }
        
        /* Top Bar */
        .top-bar {
            width: 500px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
        }
        .version {
            font-size: 1rem;
            color: #7f8c8d;
            font-family: monospace;
        }
        .help-btn {
            background: none;
            border: 2px solid #7f8c8d;
            color: #bdc3c7;
            padding: 5px 15px;
            font-size: 1rem;
            cursor: pointer;
            border-radius: 6px;
            font-weight: bold;
        }
        .help-btn:hover { background: #fff; color: #000; }

        /* Turn Indicator */
        .turn-indicator {
            margin-top: 15px;
            font-size: 1.5rem;
            font-weight: bold;
            padding: 8px 25px;
            border-radius: 25px;
            background: #222;
            color: #777;
            transition: all 0.3s;
        }
        .turn-player { background: #2ecc71; color: #fff; box-shadow: 0 0 15px #2ecc71; }
        .turn-enemy { background: #e74c3c; color: #fff; box-shadow: 0 0 15px #e74c3c; }

        /* UI Bars */
        .hud {
            width: 500px;
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 12px;
            margin-top: 15px;
        }
        .stat-box { text-align: center; width: 140px; }
        .stat-box div:first-child { font-weight: bold; font-size: 1.1rem; margin-bottom: 5px; }
        
        .bar-container {
            width: 100%;
            height: 14px;
            background: #444;
            border-radius: 7px;
            overflow: hidden;
            margin-top: 5px;
            position: relative;
        }
        .armor-container {
            width: 100%;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 4px;
        }

        .bar { height: 100%; transition: width 0.3s; }
        
        #player-hp-bar { background-color: #2ecc71; width: 100%; }
        #enemy-hp-bar { background-color: #e74c3c; width: 100%; }
        #ult-bar { background-color: #f1c40f; width: 0%; }
        
        #player-armor-bar { background-color: var(--armor-color); width: 0%; }
        #enemy-armor-bar { background-color: var(--armor-color); width: 0%; }

        .hp-text { font-size: 1rem; display: block; margin-top: 5px; font-weight: bold; }
        .armor-text { color: var(--armor-color); font-size: 0.9rem; font-weight: bold; }

        /* Game Board */
        .grid {
            width: 480px;  
            height: 480px; 
            display: flex;
            flex-wrap: wrap;
            background-color: var(--board-bg);
            border-radius: 12px;
            border: 6px solid #1a252f;
            overflow: hidden;
            position: relative;
            touch-action: none; /* Important for dragging on mobile */
        }
        .grid.locked { pointer-events: none; filter: grayscale(0.5); }

        .tile {
            width: 60px;
            height: 60px;
            font-size: 36px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab; /* Shows drag capability */
            box-sizing: border-box;
            z-index: 1;
            transition: transform 0.2s, filter 0.2s;
        }
        .tile:active { cursor: grabbing; }
        .tile:hover { filter: brightness(1.2); transform: scale(1.1); z-index: 2; }
        .selected {
            background-color: rgba(255, 255, 255, 0.2);
            border: 3px solid var(--accent);
            border-radius: 8px;
            transform: scale(1.1);
        }

        /* ANIMATIONS */
        .falling { animation: dropIn 0.4s ease-out; }
        @keyframes dropIn {
            0% { transform: translateY(-60px); opacity: 0; }
            100% { transform: translateY(0px); opacity: 1; }
        }

        .matched {
            animation: matchPop 0.4s forwards ease-in-out;
            z-index: 10;
        }
        @keyframes matchPop {
            0% { transform: scale(1); filter: brightness(2) drop-shadow(0 0 10px white); background-color: rgba(255,255,255,0.4); }
            40% { transform: scale(1.3); opacity: 1; }
            100% { transform: scale(0); opacity: 0; }
        }

        /* GAME OVERLAY */
        .game-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: var(--overlay-bg);
            z-index: 50;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            backdrop-filter: blur(4px);
        }
        .overlay-title { font-size: 2.5rem; color: var(--accent); margin-bottom: 25px; text-shadow: 3px 3px 0 #000; }
        .overlay-btn {
            padding: 20px 40px;
            font-size: 1.5rem;
            background: #27ae60;
            color: white;
            border: 3px solid #2ecc71;
            border-radius: 10px;
            cursor: pointer;
            margin: 15px;
            transition: all 0.2s;
            font-weight: bold;
        }
        .overlay-btn:hover { background: #2ecc71; transform: scale(1.05); }
        .reward-container { display: flex; flex-direction: column; gap: 15px; width: 80%; }
        .reward-btn {
            background: #2980b9;
            border: 3px solid #3498db;
            color: white;
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            text-align: left;
            font-size: 1.1rem;
        }
        .reward-btn:hover { background: #3498db; transform: translateX(5px); transition: transform 0.2s;}
        .reward-btn b { color: var(--accent); font-size: 1.2rem; }

        /* Enemy Cursor */
        .ai-cursor {
            position: absolute;
            width: 56px;
            height: 56px;
            border: 4px solid #e74c3c;
            border-radius: 50%;
            z-index: 10;
            transition: all 0.5s ease;
            pointer-events: none;
            box-shadow: 0 0 15px #e74c3c;
            display: none;
        }

        /* Popups */
        .pop-text {
            position: absolute;
            font-weight: bold;
            font-size: 2rem;
            pointer-events: none;
            animation: floatUp 1.5s forwards;
            text-shadow: 3px 3px 0 #000;
            z-index: 20;
            white-space: nowrap;
        }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(0.8); opacity: 0; }
            20% { transform: translateY(-15px) scale(1.2); opacity: 1; }
            80% { opacity: 1; }
            100% { transform: translateY(-80px) scale(1); opacity: 0; }
        }

        /* Monster Display */
        .enemy-display {
            font-size: 4rem;
            margin-bottom: 5px;
            animation: float 3s ease-in-out infinite;
        }
        #enemy-name { font-size: 1.5rem; font-weight: bold; margin-bottom: 10px; }
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-15px); }
            100% { transform: translateY(0px); }
        }

        /* Log */
        #log {
            width: 500px;
            height: 180px; /* Even taller for more details */
            background: rgba(0,0,0,0.4);
            margin-top: 15px;
            padding: 10px;
            font-size: 1rem;
            overflow-y: auto;
            border-radius: 8px;
            font-family: 'Consolas', monospace;
            display: flex;
            flex-direction: column-reverse; 
            border: 1px solid #555;
        }
        .log-hit { color: #f1c40f; }
        .log-crit { color: #ff6b6b; font-weight: bold; }
        .log-heal { color: #2ecc71; }
        .log-armor { color: #bdc3c7; }
        .log-enemy { color: #e74c3c; }
        .log-match { color: #3498db; }
        .log-turn { color: #fff; font-weight: bold; text-decoration: underline; margin-top: 5px; padding-top: 5px; border-top: 1px dashed #444;}

        /* Buttons */
        .action-btn {
            margin-top: 15px;
            padding: 15px 30px;
            background: var(--accent);
            border: none;
            cursor: pointer;
            font-weight: bold;
            border-radius: 8px;
            font-size: 1.1rem;
            color: #2c3e50;
        }
        .action-btn:disabled { background: #555; color: #888; cursor: not-allowed; }

        /* INFO MODAL */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: var(--modal-bg);
            z-index: 100;
            display: none;
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background: #34495e;
            width: 85%;
            max-width: 700px;
            max-height: 85vh;
            overflow-y: auto;
            border-radius: 12px;
            padding: 30px;
            border: 3px solid #7f8c8d;
            position: relative;
            font-size: 1.1rem;
        }
        .close-modal {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 2rem;
            cursor: pointer;
            color: #bdc3c7;
        }
        .modal-section { margin-bottom: 25px; border-bottom: 2px solid #555; padding-bottom: 20px; }
        .modal-title { color: var(--accent); margin-top: 0; font-size: 1.8rem; }
        .dual-lang { display: flex; gap: 30px; flex-wrap: wrap; }
        .lang-col { flex: 1; min-width: 280px; }
        h4 { margin-bottom: 10px; color: #3498db; font-size: 1.3rem; }
        ul { padding-left: 20px; margin-top: 5px; }
        li { margin-bottom: 8px; }
    </style>
</head>
<body>
    <div id="info-modal" class="modal-overlay">
        <div class="modal-content">
            <span class="close-modal" onclick="toggleModal()">Ã—</span>
            <div class="modal-section">
                <div class="dual-lang">
                    <div class="lang-col">
                        <h2 class="modal-title">GAME MANUAL</h2>
                        <h4>Controls / Kontroller</h4>
                        <ul>
                            <li><strong>Click & Click:</strong> Select one tile, then a neighbor.</li>
                            <li><strong>Drag & Slide:</strong> Hold click on a tile, slide to neighbor.</li>
                        </ul>
                        <h4>Mechanics</h4>
                        <ul>
                            <li><strong>Match 3:</strong> Basic action.</li>
                            <li><strong>Match 4:</strong> 2x Effect + Extra Turn.</li>
                            <li><strong>Match 5:</strong> 3x Effect + Ultimate + Extra Turn.</li>
                        </ul>
                    </div>
                    <div class="lang-col">
                        <h2 class="modal-title">OYUN KILAVUZU</h2>
                        <h4>Kontroller</h4>
                        <ul>
                            <li><strong>TÄ±kla & TÄ±kla:</strong> Bir taÅŸa tÄ±kla, sonra yanÄ±ndakine.</li>
                            <li><strong>SÃ¼rÃ¼kle & KaydÄ±r:</strong> TaÅŸa basÄ±lÄ± tut, yanÄ±ndakine kaydÄ±r.</li>
                        </ul>
                        <h4>Mekanikler</h4>
                        <ul>
                            <li><strong>3'lÃ¼ EÅŸleÅŸme:</strong> Temel hareket.</li>
                            <li><strong>4'lÃ¼ EÅŸleÅŸme:</strong> 2x Etki + Ekstra Tur.</li>
                            <li><strong>5'li EÅŸleÅŸme:</strong> 3x Etki + Ulti + Ekstra Tur.</li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="modal-section" style="border:none;">
                <h4 style="color:#777">v0.11.0 - Controls & Logging Update</h4>
                <p>Added "Hold & Slide" controls and detailed match logging.</p>
            </div>
        </div>
    </div>

    <div class="top-bar">
        <div class="version">v0.11.0 Controls+Log</div>
        <button class="help-btn" onclick="toggleModal()">Help / YardÄ±m</button>
    </div>
    
    <div class="enemy-display" id="enemy-sprite">ðŸ‘¾</div>
    <div id="enemy-name">Slime Lvl 1</div>
    
    <div id="turn-banner" class="turn-indicator turn-player">WAITING...</div>

    <div class="hud">
        <div class="stat-box">
            <div>YOU</div>
            <div class="bar-container"><div id="player-hp-bar" class="bar"></div></div>
            <div class="armor-container"><div id="player-armor-bar" class="bar"></div></div>
            <span id="hp-text" class="hp-text">100/100</span>
        </div>
        
        <div class="stat-box" style="width: 100px;">
            <div>ULT</div>
            <div class="bar-container"><div id="ult-bar" class="bar"></div></div>
        </div>
        
        <div class="stat-box">
            <div>ENEMY</div>
            <div class="bar-container"><div id="enemy-hp-bar" class="bar"></div></div>
            <div class="armor-container"><div id="enemy-armor-bar" class="bar"></div></div>
            <span id="enemy-hp-text" class="hp-text">50/50</span>
        </div>
    </div>

    <div class="grid" id="grid">
        <div class="ai-cursor" id="ai-cursor"></div>
        <div id="game-overlay" class="game-overlay">
            <h1 id="overlay-title" class="overlay-title">PIXEL MATCH RPG</h1>
            <div id="reward-area" class="reward-container" style="display:none;"></div>
            <button id="overlay-btn" class="overlay-btn" onclick="handleOverlayClick()">START BATTLE / BAÅžLA</button>
        </div>
    </div>
    
    <div id="log"></div>
    <button onclick="useUltimate()" id="ult-btn" class="action-btn" disabled>USE ULTIMATE (Requires 100%)</button>

    <script>
        const gridDisplay = document.querySelector('.grid');
        const logDisplay = document.getElementById('log');
        const turnBanner = document.getElementById('turn-banner');
        const aiCursor = document.getElementById('ai-cursor');
        const modal = document.getElementById('info-modal');
        
        // Overlay Elements
        const overlay = document.getElementById('game-overlay');
        const overlayTitle = document.getElementById('overlay-title');
        const overlayBtn = document.getElementById('overlay-btn');
        const rewardArea = document.getElementById('reward-area');

        const width = 8;
        const tiles = [];

        // --- DYNAMIC STATS (Mutable) ---
        let TILE_STATS = {
            sword: 6,
            heart: 4,
            shield: 5,
            energy: 12,
            skull_dmg: 25,
            skull_self: 8,
            ult_dmg: 35
        };

        const STATE = { START: 0, PLAYING: 1, REWARD: 2, GAMEOVER: 3 };
        let currentState = STATE.START;

        // Player Stats
        let playerHP = 100;
        let maxPlayerHP = 100;
        let playerArmor = 0;
        let ultCharge = 0;

        // Level Stats
        let level = 1;
        let enemyHP = 50;
        let maxEnemyHP = 50;
        let enemyArmor = 0;

        // Log Counter
        let logCounter = 1;

        let isProcessing = false;
        let isPlayerTurn = true;
        let extraTurnTriggered = false;

        // Input Handling State
        let isMouseDown = false;
        let selectedTile = null;

        const tileTypes = [
            { type: 'sword', symbol: 'âš”ï¸' },
            { type: 'heart', symbol: 'ðŸ’–' },
            { type: 'shield', symbol: 'ðŸ›¡ï¸' },
            { type: 'energy', symbol: 'âš¡' },
            { type: 'skull', symbol: 'ðŸ’€' }
        ];

        // --- GLOBAL INPUT LISTENERS FOR DRAG RELEASE ---
        document.body.addEventListener('mouseup', () => { isMouseDown = false; });
        document.body.addEventListener('mouseleave', () => { isMouseDown = false; });

        // --- OVERLAY & GAME FLOW ---

        function handleOverlayClick() {
            if (currentState === STATE.START || currentState === STATE.GAMEOVER) {
                resetGame();
                startLevel();
            } else if (currentState === STATE.REWARD) {
                startLevel();
            }
        }

        function resetGame() {
            playerHP = 100;
            maxPlayerHP = 100;
            playerArmor = 0;
            ultCharge = 0;
            level = 1;
            logCounter = 1;
            
            TILE_STATS = { sword: 6, heart: 4, shield: 5, energy: 12, skull_dmg: 25, skull_self: 8, ult_dmg: 35 };
            
            log("Game Reset.", "log-turn");
        }

        function startLevel() {
            currentState = STATE.PLAYING;
            overlay.style.display = 'none'; 
            
            maxEnemyHP = 50 + ((level - 1) * 20);
            enemyHP = maxEnemyHP;
            enemyArmor = 0;
            
            document.getElementById('enemy-name').innerText = `Enemy Lvl ${level}`;
            document.getElementById('enemy-sprite').innerText = ['ðŸ‘¾','ðŸ‘¹','ðŸ‘º','ðŸ‘»','ðŸ¤–'][level % 5];
            
            turnBanner.innerText = "PLAYER TURN";
            turnBanner.className = "turn-indicator turn-player";
            isPlayerTurn = true;
            isProcessing = false;
            
            createBoard();
            updateUI();
            log(`LEVEL ${level} START`, "log-turn");
        }

        function winLevel() {
            currentState = STATE.REWARD;
            log("Level Complete! Choose a reward.", "log-hit");
            
            overlay.style.display = 'flex';
            overlayTitle.innerText = "VICTORY! / ZAFER!";
            overlayBtn.style.display = 'none';
            rewardArea.style.display = 'flex';
            
            generateRewards();
        }

        function generateRewards() {
            rewardArea.innerHTML = '';
            
            const pool = [
                { id: 'sword', en: "Sharpen Swords (+1 Dmg)", tr: "KÄ±lÄ±Ã§larÄ± Bile (+1 Hasar)", fn: () => TILE_STATS.sword += 1 },
                { id: 'shield', en: "Reinforce Shields (+1 Armor)", tr: "KalkanlarÄ± GÃ¼Ã§lendir (+1 ZÄ±rh)", fn: () => TILE_STATS.shield += 1 },
                { id: 'heart', en: "Potent Potions (+1 Heal)", tr: "GÃ¼Ã§lÃ¼ Ä°ksirler (+1 Can)", fn: () => TILE_STATS.heart += 1 },
                { id: 'hp', en: "Vitality (+20 Max HP)", tr: "CanlÄ±lÄ±k (+20 Max Can)", fn: () => { maxPlayerHP += 20; playerHP += 20; } },
                { id: 'energy', en: "Focus (+2 Ult Charge)", tr: "Odaklanma (+2 Åžarj)", fn: () => TILE_STATS.energy += 2 },
                { id: 'ult', en: "Ult Power (+10 Dmg)", tr: "Ulti GÃ¼cÃ¼ (+10 Hasar)", fn: () => TILE_STATS.ult_dmg += 10 }
            ];

            pool.sort(() => 0.5 - Math.random());
            const choices = pool.slice(0, 3);

            choices.forEach(reward => {
                let btn = document.createElement('button');
                btn.className = 'reward-btn';
                btn.innerHTML = `<b>${reward.en}</b><br><small>${reward.tr}</small>`;
                btn.onclick = () => {
                    reward.fn();
                    log(`Upgraded: ${reward.en}`, "log-heal");
                    showReadyForNext();
                };
                rewardArea.appendChild(btn);
            });
        }

        function showReadyForNext() {
            rewardArea.style.display = 'none';
            overlayTitle.innerText = `READY FOR LEVEL ${level + 1}?`;
            overlayBtn.innerText = "START NEXT LEVEL / SIRADAKÄ° SEVÄ°YE";
            overlayBtn.style.display = 'block';
            
            playerHP = Math.min(playerHP + 10, maxPlayerHP);
            level++;
        }

        function gameOver() {
            currentState = STATE.GAMEOVER;
            overlay.style.display = 'flex';
            overlayTitle.innerText = "GAME OVER";
            overlayBtn.innerText = "TRY AGAIN / TEKRAR DENE";
            overlayBtn.style.display = 'block';
            rewardArea.style.display = 'none';
        }

        // --- CORE GAME LOGIC ---

        function toggleModal() {
            modal.style.display = (modal.style.display === 'flex') ? 'none' : 'flex';
        }

        function createBoard() {
            gridDisplay.innerHTML = ''; 
            gridDisplay.appendChild(aiCursor); 
            gridDisplay.appendChild(overlay); 
            tiles.length = 0;
            for (let i = 0; i < width * width; i++) {
                const tile = document.createElement('div');
                tile.setAttribute('id', i);
                let randomType = Math.floor(Math.random() * tileTypes.length);
                tile.dataset.type = tileTypes[randomType].type;
                tile.innerHTML = tileTypes[randomType].symbol;
                tile.classList.add('tile');
                gridDisplay.appendChild(tile);
                tiles.push(tile);
                
                // MOUSE INPUT (Drag & Click)
                tile.addEventListener('mousedown', (e) => handleInputStart(tile));
                tile.addEventListener('mouseenter', (e) => handleInputEnter(tile));
            }
            resolveMatches(true); 
            updateUI();
        }

        // --- NEW INPUT HANDLING ---
        function handleInputStart(tile) {
            if (currentState !== STATE.PLAYING) return;
            if (isProcessing || !isPlayerTurn) return;

            isMouseDown = true;

            if (!selectedTile) {
                // Select first tile
                selectedTile = tile;
                tile.classList.add('selected');
            } else {
                // Standard Click-Click Swap
                if (tile !== selectedTile) {
                    checkAndSwap(selectedTile, tile);
                } else {
                    // Deselect if clicking same tile
                    selectedTile.classList.remove('selected');
                    selectedTile = null;
                }
            }
        }

        function handleInputEnter(tile) {
            if (!isMouseDown || !selectedTile || isProcessing) return;
            
            if (tile !== selectedTile) {
                // Dragged into a new tile -> Attempt Drag Swap
                checkAndSwap(selectedTile, tile);
            }
        }

        function checkAndSwap(tile1, tile2) {
            let id1 = parseInt(tile1.id);
            let id2 = parseInt(tile2.id);
            const validMoves = [id1 - 1, id1 + 1, id1 - width, id1 + width];
            
            if (validMoves.includes(id2)) {
                // Valid Neighbor -> Swap
                attemptSwap(tile1, tile2);
                
                // Reset Selection & Drag State after swap attempt
                tile1.classList.remove('selected');
                selectedTile = null;
                isMouseDown = false; 
            } else {
                // Invalid neighbor (clicked far away) -> Change selection
                if (!isMouseDown) { // Only change selection on click, not drag pass-through
                    tile1.classList.remove('selected');
                    selectedTile = tile2;
                    tile2.classList.add('selected');
                }
            }
        }

        function attemptSwap(tile1, tile2) {
            isProcessing = true;
            let tempType = tile1.dataset.type;
            let tempHTML = tile1.innerHTML;
            tile1.dataset.type = tile2.dataset.type;
            tile1.innerHTML = tile2.innerHTML;
            tile2.dataset.type = tempType;
            tile2.innerHTML = tempHTML;

            let hasMatch = checkForMatches(false); 
            
            if (!hasMatch) {
                setTimeout(() => {
                    let tempType = tile1.dataset.type;
                    let tempHTML = tile1.innerHTML;
                    tile1.dataset.type = tile2.dataset.type;
                    tile1.innerHTML = tile2.innerHTML;
                    tile2.dataset.type = tempType;
                    tile2.innerHTML = tempHTML;
                    isProcessing = false; 
                }, 200);
            }
        }

        function resolveMatches(isInitial) {
            checkForMatches(isInitial);
        }

        function checkForMatches(isInitial) {
            let matchesFound = false;
            let hRuns = [];
            let vRuns = [];

            // Horizontal
            for (let r = 0; r < width; r++) {
                let count = 1;
                for (let c = 0; c < width; c++) {
                    let i = r * width + c;
                    if (c < width-1 && tiles[i].dataset.type !== '' && tiles[i].dataset.type === tiles[i+1].dataset.type) {
                        count++;
                    } else {
                        if (count >= 3) {
                            let indices = [];
                            for(let k=0; k<count; k++) indices.push(i-k);
                            hRuns.push({indices: indices, type: tiles[i].dataset.type});
                            matchesFound = true;
                        }
                        count = 1;
                    }
                }
            }
            // Vertical
            for (let c = 0; c < width; c++) {
                let count = 1;
                for (let r = 0; r < width; r++) {
                    let i = r * width + c;
                    if (r < width-1 && tiles[i].dataset.type !== '' && tiles[i].dataset.type === tiles[i+width].dataset.type) {
                        count++;
                    } else {
                        if (count >= 3) {
                            let indices = [];
                            for(let k=0; k<count; k++) indices.push(i-(k*width));
                            vRuns.push({indices: indices, type: tiles[i].dataset.type});
                            matchesFound = true;
                        }
                        count = 1;
                    }
                }
            }

            let finalGroups = [...hRuns, ...vRuns];
            
            if (finalGroups.length > 0) {
                finalGroups.forEach(group => processMatch(group, isInitial));
                setTimeout(() => fillBoard(isInitial), 400);
                return true;
            } else {
                if (!isInitial) isProcessing = false;
                return false;
            }
        }

        function processMatch(group, isInitial) {
            let shape = '3';
            if (group.indices.length === 4) shape = '4';
            if (group.indices.length >= 5) shape = '5';
            
            let validTiles = 0;
            
            // --- DETAILED LOGGING (New) ---
            if (!isInitial && group.indices.length > 0) {
                // Find icon
                let typeInfo = tileTypes.find(t => t.type === group.type);
                let icon = typeInfo ? typeInfo.symbol : "?";
                let user = isPlayerTurn ? "Player" : "Enemy";
                let msg = `${user} matched ${group.indices.length} ${icon}`;
                
                if (shape === '4') msg += " (2x Bonus!)";
                if (shape === '5') msg += " (3x Bonus!)";
                
                log(msg, "log-match");
            }
            // ------------------------------

            group.indices.forEach(index => {
                if (tiles[index].dataset.type !== '') {
                    if (!isInitial) tiles[index].classList.add('matched');
                    else tiles[index].innerHTML = ''; 
                    
                    tiles[index].dataset.type = '';
                    validTiles++;
                }
            });

            if (validTiles > 0 && !isInitial) {
                if (shape === '4' || shape === '5') {
                    extraTurnTriggered = true;
                    let center = tiles[group.indices[1]];
                    let text = shape === '5' ? "LEGENDARY!" : "CRITICAL!";
                    let color = shape === '5' ? "#f1c40f" : "#ff6b6b";
                    showFloatingText(text, center, color);
                }
                applyRPGEffects(group.type, shape);
            }
        }

        function showFloatingText(text, tileElement, color) {
            let rect = tileElement.getBoundingClientRect();
            let pop = document.createElement('div');
            pop.classList.add('pop-text');
            pop.innerText = text;
            pop.style.color = color;
            pop.style.left = (rect.left + window.scrollX) + 'px';
            pop.style.top = (rect.top + window.scrollY) + 'px';
            document.body.appendChild(pop);
            setTimeout(() => pop.remove(), 1500);
        }

        function applyRPGEffects(type, shape) {
            if (currentState !== STATE.PLAYING) return;

            let multiplier = 1;
            if (shape === '4') multiplier = 2;
            if (shape === '5') multiplier = 3;

            let user = isPlayerTurn ? "Player" : "Enemy";
            
            if (type === 'sword') {
                let baseVal = TILE_STATS.sword * multiplier;
                let target = isPlayerTurn ? 'enemy' : 'player';
                inflictDamage(target, baseVal);
                log(`${user} attacks for ${baseVal} dmg`, isPlayerTurn ? 'log-hit' : 'log-enemy');
            
            } else if (type === 'heart') {
                let baseVal = TILE_STATS.heart * multiplier;
                if (isPlayerTurn) playerHP = Math.min(playerHP + baseVal, maxPlayerHP);
                else enemyHP = Math.min(enemyHP + baseVal, maxEnemyHP);
                log(`${user} heals +${baseVal} HP`, 'log-heal');
            
            } else if (type === 'shield') {
                let baseVal = TILE_STATS.shield * multiplier;
                if (isPlayerTurn) playerArmor += baseVal;
                else enemyArmor += baseVal;
                log(`${user} gains +${baseVal} Armor`, 'log-armor');
            
            } else if (type === 'energy') {
                let baseVal = TILE_STATS.energy * multiplier;
                if (isPlayerTurn) {
                    ultCharge = Math.min(ultCharge + baseVal, 100);
                    log(`Ult Charge: +${baseVal}%`, 'log-hit');
                } else {
                    let absorb = Math.floor(baseVal / 2);
                    enemyHP = Math.min(enemyHP + absorb, maxEnemyHP);
                    log(`Enemy absorbs ${absorb} HP`, "log-enemy");
                }
            
            } else if (type === 'skull') {
                let dmgToOpponent = TILE_STATS.skull_dmg * (shape === '3' ? 1 : 1.5);
                let recoil = TILE_STATS.skull_self * (shape === '3' ? 1 : 1.5);

                let target = isPlayerTurn ? 'enemy' : 'player';
                let self = isPlayerTurn ? 'player' : 'enemy';

                inflictDamage(target, dmgToOpponent);
                inflictDamage(self, recoil);
                log(`SKULLS! ${user} takes ${recoil}, Target takes ${dmgToOpponent}`, 'log-crit');
            }

            if (shape === '5' && isPlayerTurn) {
                ultCharge = 100;
                log("LEGENDARY! ULT READY!", "log-hit");
            }

            checkWinCondition();
            updateUI();
        }

        function inflictDamage(targetStr, amount) {
            if (targetStr === 'player') {
                if (playerArmor >= amount) {
                    playerArmor -= amount; 
                } else {
                    let remainder = amount - playerArmor;
                    playerArmor = 0;
                    playerHP -= remainder;
                }
            } else {
                if (enemyArmor >= amount) {
                    enemyArmor -= amount;
                } else {
                    let remainder = amount - enemyArmor;
                    enemyArmor = 0;
                    enemyHP -= remainder;
                }
            }
        }

        function fillBoard(isInitial) {
            for (let col = 0; col < width; col++) {
                let columnTiles = [];
                for (let row = 0; row < width; row++) {
                    let index = col + (row * width);
                    if (tiles[index].dataset.type !== '') {
                        columnTiles.push({ type: tiles[index].dataset.type, html: tiles[index].innerHTML });
                    }
                }
                let missingCount = width - columnTiles.length;
                for (let i = 0; i < missingCount; i++) {
                    let randomType = Math.floor(Math.random() * tileTypes.length);
                    columnTiles.unshift({ type: tileTypes[randomType].type, html: tileTypes[randomType].symbol, isNew: true });
                }
                for (let row = 0; row < width; row++) {
                    let index = col + (row * width);
                    let tileData = columnTiles[row];
                    
                    if (tiles[index].dataset.type !== tileData.type || tileData.isNew) {
                        tiles[index].dataset.type = tileData.type;
                        tiles[index].innerHTML = tileData.html;
                        tiles[index].classList.remove('matched');
                        
                        if (!isInitial) {
                            tiles[index].classList.remove('falling');
                            void tiles[index].offsetWidth; 
                            tiles[index].classList.add('falling');
                        }
                    }
                }
            }

            let chainReaction = checkForMatches(isInitial);
            
            if (!chainReaction && !isInitial) {
                endTurnLogic();
            }
        }

        function endTurnLogic() {
            if (currentState !== STATE.PLAYING) return;

            if (extraTurnTriggered) {
                log(isPlayerTurn ? ">> YOU GET AN EXTRA TURN!" : ">> ENEMY GETS AN EXTRA TURN!", "log-turn");
                extraTurnTriggered = false;
                isProcessing = false;
                if (!isPlayerTurn) setTimeout(enemyPlayTurn, 1000); 
                else { gridDisplay.classList.remove('locked'); }
            } else {
                isPlayerTurn = !isPlayerTurn;
                updateTurnBanner();
                
                if (!isPlayerTurn) {
                    gridDisplay.classList.add('locked'); 
                    setTimeout(enemyPlayTurn, 1500);
                } else {
                    gridDisplay.classList.remove('locked');
                    isProcessing = false;
                }
            }
        }

        function updateTurnBanner() {
            if (isPlayerTurn) {
                turnBanner.innerText = "PLAYER TURN";
                turnBanner.className = "turn-indicator turn-player";
            } else {
                turnBanner.innerText = "ENEMY TURN";
                turnBanner.className = "turn-indicator turn-enemy";
            }
        }

        function enemyPlayTurn() {
            if (currentState !== STATE.PLAYING) return;

            let bestMove = findBestMove();

            if (bestMove) {
                let t1 = tiles[bestMove.index];
                let t2 = tiles[bestMove.target];
                
                aiCursor.style.display = 'block';
                aiCursor.style.left = (t1.offsetLeft) + 'px';
                aiCursor.style.top = (t1.offsetTop) + 'px';

                setTimeout(() => {
                    aiCursor.style.left = (t2.offsetLeft) + 'px';
                    aiCursor.style.top = (t2.offsetTop) + 'px';
                }, 500);

                setTimeout(() => {
                    aiCursor.style.display = 'none';
                    attemptSwap(t1, t2);
                }, 1000);

            } else {
                log("Enemy found no moves. Passing...", "log-enemy");
                isPlayerTurn = true;
                updateTurnBanner();
                gridDisplay.classList.remove('locked');
                isProcessing = false;
            }
        }

        function findBestMove() {
            let possibleMoves = [];
            for (let i = 0; i < 64; i++) {
                let r = Math.floor(i / width);
                let c = i % width;
                if (c < width - 1) {
                    let score = simulateSwap(i, i + 1);
                    if (score > 0) possibleMoves.push({index: i, target: i + 1, score: score});
                }
                if (r < width - 1) {
                    let score = simulateSwap(i, i + width);
                    if (score > 0) possibleMoves.push({index: i, target: i + width, score: score});
                }
            }
            possibleMoves.sort((a, b) => b.score - a.score);
            return possibleMoves.length > 0 ? possibleMoves[0] : null;
        }

        function simulateSwap(i1, i2) {
            let tempTypes = tiles.map(t => t.dataset.type);
            let h = tempTypes[i1]; tempTypes[i1] = tempTypes[i2]; tempTypes[i2] = h;
            let score = 0;
             for (let r = 0; r < width; r++) {
                for (let c = 0; c < width - 2; c++) {
                    let idx = r * width + c;
                    let t = tempTypes[idx];
                    if (!t) continue;
                    if (tempTypes[idx+1] == t && tempTypes[idx+2] == t) score += calculateScore(t, 3);
                }
            }
            for (let c = 0; c < width; c++) {
                for (let r = 0; r < width - 2; r++) {
                    let idx = r * width + c;
                    let t = tempTypes[idx];
                    if (!t) continue;
                    if (tempTypes[idx+width] == t && tempTypes[idx+width*2] == t) score += calculateScore(t, 3);
                }
            }
            return score;
        }

        function calculateScore(type, length) {
            let base = 10;
            if (type === 'skull') base += 25; 
            if (type === 'shield' && enemyArmor < 10) base += 20; 
            if (type === 'sword') base += 5;
            return base;
        }

        function useUltimate() {
            if (ultCharge >= 100 && isPlayerTurn && currentState === STATE.PLAYING) {
                inflictDamage('enemy', TILE_STATS.ult_dmg);
                ultCharge = 0;
                log(`ULTIMATE! ${TILE_STATS.ult_dmg} Damage!`, "log-hit");
                checkWinCondition();
                updateUI();
            }
        }

        function checkWinCondition() {
            if (currentState !== STATE.PLAYING) return;

            if (enemyHP <= 0) {
                winLevel();
            } else if (playerHP <= 0) {
                gameOver();
            }
        }

        function updateUI() {
            const pPct = Math.max(0, (playerHP / maxPlayerHP) * 100);
            const ePct = Math.max(0, (enemyHP / maxEnemyHP) * 100);
            const pArmPct = Math.min(100, (playerArmor / maxPlayerHP) * 100);
            const eArmPct = Math.min(100, (enemyArmor / maxEnemyHP) * 100);

            document.getElementById('player-hp-bar').style.width = `${pPct}%`;
            document.getElementById('enemy-hp-bar').style.width = `${ePct}%`;
            document.getElementById('ult-bar').style.width = `${ultCharge}%`;
            
            document.getElementById('player-armor-bar').style.width = `${pArmPct}%`;
            document.getElementById('enemy-armor-bar').style.width = `${eArmPct}%`;
            
            let pArmorText = playerArmor > 0 ? ` <span class="armor-text">[+${playerArmor}]</span>` : "";
            let eArmorText = enemyArmor > 0 ? ` <span class="armor-text">[+${enemyArmor}]</span>` : "";

            document.getElementById('hp-text').innerHTML = `${Math.floor(Math.max(0,playerHP))}/${maxPlayerHP}${pArmorText}`;
            document.getElementById('enemy-hp-text').innerHTML = `${Math.floor(Math.max(0,enemyHP))}/${maxEnemyHP}${eArmorText}`;

            document.getElementById('ult-btn').disabled = ultCharge < 100 || !isPlayerTurn;
        }

        function log(msg, cls) {
            let div = document.createElement('div');
            div.innerText = `#${logCounter++} > ${msg}`;
            if(cls) div.classList.add(cls);
            logDisplay.prepend(div);
        }

        // Initialize Overlay but don't start level yet
        createBoard();
    </script>
</body>
</html>